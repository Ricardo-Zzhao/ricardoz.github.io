<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>数据结构-图 - 书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="数据结构-图"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/author.jpg"><meta name=title content="数据结构-图 - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/data-structure-graph/ itemprop=url>数据结构-图</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-03-16">2020-03-16</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>爱编程爱技术的孩子</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>6233 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>13分钟</span></span>
<span id=/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/data-structure-graph/ class=leancloud_visitors data-flag-title=数据结构-图>|
<i class="fa fa-binoculars fa-fw"></i><span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。</p><h2 id=1-图的定义>1. 图的定义</h2><p>用 V(Vertex) 表示顶点的集合，用 E(Edge) 表示边的集合，则图可以看作由一个非空的有限顶点集合 V 和一个有限边的集合 E 组成，记作G(V, E)。其中</p><ul><li>边可以表示为顶点对：(v, w) ∈ E，其中 v, w ∈ V</li><li>无向边使用小括号包含两个顶点来表示，如上一条所示，有向边可以用 &lt;v, w> 表示</li><li>不考虑重边和自回路（这样的图称为简单图，我们只考虑这种图）</li></ul><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0u9K.png alt=一个无向图的例子></p><p>一些概念解释如下</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>弧（Arc）</td><td>边的另一种称呼</td></tr><tr><td>无向图（Digraph）</td><td>图中所有的边没有特定的指向</td></tr><tr><td>有向图（Undigraph）</td><td>图中所有的边是有向的</td></tr><tr><td>完全图</td><td>任意两个顶点间都有边相连</td></tr><tr><td>权（Weight）</td><td>与图的边有关的数，可能表示顶点的距离或花费</td></tr><tr><td>顶点的度（Degree)</td><td>对无向图，顶点所连接的边的数量</td></tr><tr><td>顶点的入度（Indegree）</td><td>对有向图，指向顶点的边的数量</td></tr><tr><td>顶点的出度（Outdegree）</td><td>对有向图，从顶点出发的边的数量</td></tr><tr><td>路径（Path）</td><td>从一个顶点到另一个顶点的顶点序列</td></tr><tr><td>路径长度</td><td>路径上边的数目</td></tr><tr><td>连通图</td><td>从一个顶点开始，可以到达图中任意一个其它顶点</td></tr><tr><td>非连通图</td><td>图中存在不可达的顶点</td></tr><tr><td>连通分量</td><td>对非连通图，它的极大连通子图称为连通分量</td></tr><tr><td>网</td><td>带权的连通图</td></tr></tbody></table><p>关于图的操作集有很多，但最基本的如下</p><ul><li>Create()：建立并返回空图</li><li>InsertVertex(Graph G, Vertex V)：将顶点 V 插入图 G</li><li>InsertEdge(Graph G, Edge E)：将边 E 插入图 G</li><li>DFS(Graph G, Vertex V)：从顶点 V 出发深度优先遍历图 G</li><li>BFS(Graph G, Vertex V)：从顶点 V 出发广度优先遍历图 G</li><li>ShortestPath(Graph G, Vertex V, int Dist[])：计算图 G 中顶点 V 到任意其它顶点的最短路径</li><li>MST(Graph G)：计算图的最小生成树</li></ul><h2 id=2-图的表示>2. 图的表示</h2><p>图的表示有<strong>很多种方法</strong>，包括邻接矩阵、邻接表、十字链表和多重邻接表，最常用的是邻接矩阵和邻接表。</p><h3 id=21-邻接矩阵>2.1 邻接矩阵</h3><p>通过邻接矩阵$G[N] [N]$表示图，首先将 N 个顶点从0到 N-1 编号，然后按如下公式填入数值。即如果两个顶点有边连接，填入1，如果没有边，则填入 0
$$
G[N][N] = \begin{cases} 1& 若&lt;v_i,v_j>是G中的边 \\ 0& 否则 \end{cases}
$$
下面是一个无向图的邻接矩阵表示</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd.png alt=图的邻接矩阵表示></p><p>实际编程时，通常使用二维数组的形式存储。对于无向图而言，邻接矩阵是对称的，因此通过只存储下三角矩阵或上三角矩阵的形式，可以节省一半的存储空间（矩阵压缩）。无向图的度是对应行（或列）非0元素的个数。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0U9f.png alt=下三角邻接矩阵></p><p>对于有向图来讲，邻接矩阵并不是对称的，因此不能采用这种方式。有向图对应行非0元素的个数是「出度」，对应列非0元素的个数是「入读」。</p><p>以上我们谈到的都是无权图，如果是有权图，如果两个顶点有边连接，填入边的权值，如果没有边连接，为$\infty$</p><p>如果是稠密图（边很多），使用邻接矩阵比较合适。如果是稀疏图（点很多而边很少），存在大量的无效元素，使用邻接矩阵会浪费大量的存储空间。</p><p>邻接矩阵结构可以定义为</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#a2f;font-weight:700>type</span> Graph <span style=color:#a2f;font-weight:700>struct</span> {
	VNum,ENUM      <span style=color:#0b0;font-weight:700>int</span>     <span style=color:#080;font-style:italic>// 顶点和边的个数
</span><span style=color:#080;font-style:italic></span>    Vertex    []<span style=color:#0b0;font-weight:700>int</span>     <span style=color:#080;font-style:italic>// 每个顶点的值
</span><span style=color:#080;font-style:italic></span>	AdjMatrix [][]<span style=color:#0b0;font-weight:700>int</span> <span style=color:#080;font-style:italic>// 邻接矩阵
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><h3 id=22-邻接表>2.2 邻接表</h3><p>邻接表适用于稀疏图的情况。将所有顶点用一个指针数组$G[N]$表示，每个元素表示一个节点，其值指向该顶点所有相邻顶点构成的链表（顺序不重要，可以随意），一个有向图的邻接表示例如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png alt></p><p>邻接表结构可以定义为</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> ENode <span style=color:#a2f;font-weight:700>struct</span> {
    V           <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//顶点编号
</span><span style=color:#080;font-style:italic></span>    Weight      <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//边的权重(可选，无权图没有这个值)
</span><span style=color:#080;font-style:italic></span>    NextEdge       <span style=color:#666>*</span>ENode     <span style=color:#080;font-style:italic>//指向下一个邻接点
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>type</span> VNode <span style=color:#a2f;font-weight:700>struct</span> {
    data      <span style=color:#0b0;font-weight:700>int</span>      <span style=color:#080;font-style:italic>//顶点信息
</span><span style=color:#080;font-style:italic></span>    FirstEdge   <span style=color:#666>*</span>Enode  <span style=color:#080;font-style:italic>//指向第一个邻接点
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>type</span> Graph <span style=color:#a2f;font-weight:700>struct</span> {
    VNum,ENum      <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//顶点和边的个数
</span><span style=color:#080;font-style:italic></span>    AdjList        []VNode   <span style=color:#080;font-style:italic>//存顶点
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>邻接表方便寻找任一顶点的所有邻接点，可以节省存储空间，但对有向图无法计算顶点的出度，需要构造「逆邻接表」，上面有向图的逆邻接表如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png alt></p><h3 id=23-十字链表>2.3 十字链表</h3><p>十字链表可以看作将图的邻接表和逆邻接表结合的产物。和邻接表相同，图的顶点信息存在顶点数组中，数组元素有三个域：data域，存放与顶点相关的信息；FirstIn域，指向第一条指向它的弧；FirstOut域，指向一个单链表，单链表中存放所有该结点发出的弧。单链表的每个表结点对应一条弧，每个表结点有5个域：vtail和vhead分别是该弧两个顶点在图中的位置，weight存储弧的权重（可选），vtail指向同一弧尾的下一条弧，vhead指向同一弧头的下一条弧。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> ENode <span style=color:#a2f;font-weight:700>struct</span> {
    vtail,vhead              <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//弧尾和弧头顶点编号
</span><span style=color:#080;font-style:italic></span>    Weight                   <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//边的权重(可选，无权图没有这个值)
</span><span style=color:#080;font-style:italic></span>    nexttail,nexthead        <span style=color:#666>*</span>ENode     <span style=color:#080;font-style:italic>//指向同弧尾和同弧头的弧结点
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>type</span> VNode <span style=color:#a2f;font-weight:700>struct</span> {
    data              <span style=color:#0b0;font-weight:700>int</span>      <span style=color:#080;font-style:italic>//顶点信息
</span><span style=color:#080;font-style:italic></span>    FirstIn,FirstOut   <span style=color:#666>*</span>Enode  <span style=color:#080;font-style:italic>//指向第一个邻接点
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>type</span> Graph <span style=color:#a2f;font-weight:700>struct</span> {
    VNum,ENum      <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//顶点和边的个数
</span><span style=color:#080;font-style:italic></span>    AdjList        []VNode   <span style=color:#080;font-style:italic>//存顶点
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>一个十字链表如下图所示，A只有出弧没有入弧，所以第一个指针为nil，第二个指针指向弧&lt;A, B>。弧结点&lt;A, B>没有同弧尾的结点，即除了A没有其它结点指向B，所以第一个指针为nil，但同弧头的还有弧结点&lt;A, C>。这里的同弧头和同弧尾都是相对于弧来说的，因此，对弧结点&lt;A, C>，同弧尾的还有&lt;B, C>，但同弧头的到此为止。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LIyse.png alt=十字链表></p><p>可以看出，基本结构是邻接表结构，只是添加了一个额外的指针域。</p><h3 id=24-邻接多重表>2.4 邻接多重表</h3><p>邻接多重表是邻接表的一种改进，只适用于无向图。在此存储结构中，图的顶点信息存放在顶点数组中，数组元素有两个域：data域，存放与顶点相关的信息；FirstEdge域，指向一个单链表，此单链表存储所有依附于该顶点的边的信息。这些单链表的一个表结点对应一条边，表结点有4个域：vexi和vexj分别存放该边两个顶点在图中的位置；nexti 指向下一条依附于顶点vexi的边对应的表结点，nextj 指向下一条依附于顶点vexj的边对应的表结点。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> ENode <span style=color:#a2f;font-weight:700>struct</span> {
    vexi,vexj          <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//边的两个顶点
</span><span style=color:#080;font-style:italic></span>    nexti,nextj        <span style=color:#666>*</span>ENode     <span style=color:#080;font-style:italic>//两个顶点所依附的下一条边
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>type</span> VNode <span style=color:#a2f;font-weight:700>struct</span> {
    data              <span style=color:#0b0;font-weight:700>int</span>      <span style=color:#080;font-style:italic>//顶点信息
</span><span style=color:#080;font-style:italic></span>    FirstEdge          <span style=color:#666>*</span>Enode  <span style=color:#080;font-style:italic>//指向第一条边
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>type</span> Graph <span style=color:#a2f;font-weight:700>struct</span> {
    VNum,ENum      <span style=color:#0b0;font-weight:700>int</span>         <span style=color:#080;font-style:italic>//顶点和边的个数
</span><span style=color:#080;font-style:italic></span>    AdjList        []VNode     <span style=color:#080;font-style:italic>//存顶点
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>一个示例如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png alt></p><h2 id=3-图的构建>3. 图的构建</h2><p>我们以邻接矩阵形式存储，定义图的结构体如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Graph <span style=color:#a2f;font-weight:700>struct</span> {
	VNum      <span style=color:#0b0;font-weight:700>int</span>     <span style=color:#080;font-style:italic>// the number of Vertices
</span><span style=color:#080;font-style:italic></span>	ENum      <span style=color:#0b0;font-weight:700>int</span>     <span style=color:#080;font-style:italic>// the numver of Edges
</span><span style=color:#080;font-style:italic></span>	AdjMatrix [][]<span style=color:#0b0;font-weight:700>int</span> <span style=color:#080;font-style:italic>// adjacency matrix
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>为了方便测试，不建立 CreateVertex() 和 CreateEdge() 函数，而是直接对结构体进行初始化从而创建图，创建了一个无向图和一个有向图</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>CreateUndirectedGraph</span>() <span style=color:#666>*</span>Graph {
	g <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>Graph{}
	g.VNum, g.ENum = <span style=color:#666>6</span>, <span style=color:#666>6</span>
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; <span style=color:#666>7</span>; i<span style=color:#666>++</span> {
		<span style=color:#080;font-style:italic>//为了便于操作和理解，从下标为1开始
</span><span style=color:#080;font-style:italic></span>		g.AdjMatrix = <span style=color:#a2f>append</span>(g.AdjMatrix, <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>7</span>))
	}
	g.AdjMatrix[<span style=color:#666>1</span>][<span style=color:#666>2</span>], g.AdjMatrix[<span style=color:#666>1</span>][<span style=color:#666>3</span>], g.AdjMatrix[<span style=color:#666>1</span>][<span style=color:#666>4</span>] = <span style=color:#666>1</span>, <span style=color:#666>1</span>, <span style=color:#666>1</span>
	g.AdjMatrix[<span style=color:#666>2</span>][<span style=color:#666>1</span>], g.AdjMatrix[<span style=color:#666>2</span>][<span style=color:#666>5</span>] = <span style=color:#666>1</span>, <span style=color:#666>1</span>
	g.AdjMatrix[<span style=color:#666>3</span>][<span style=color:#666>1</span>], g.AdjMatrix[<span style=color:#666>3</span>][<span style=color:#666>5</span>] = <span style=color:#666>1</span>, <span style=color:#666>1</span>
	g.AdjMatrix[<span style=color:#666>4</span>][<span style=color:#666>1</span>] = <span style=color:#666>1</span>
	g.AdjMatrix[<span style=color:#666>5</span>][<span style=color:#666>2</span>], g.AdjMatrix[<span style=color:#666>5</span>][<span style=color:#666>3</span>], g.AdjMatrix[<span style=color:#666>5</span>][<span style=color:#666>6</span>] = <span style=color:#666>1</span>, <span style=color:#666>1</span>, <span style=color:#666>1</span>
	g.AdjMatrix[<span style=color:#666>6</span>][<span style=color:#666>5</span>] = <span style=color:#666>1</span>
	<span style=color:#a2f;font-weight:700>return</span> g
}

<span style=color:#080;font-style:italic>// 初始化一个图，顶点和边的数量、权值都预设好
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>CreateDirectedGraph</span>() <span style=color:#666>*</span>Graph {
	g <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>Graph{}
	g.VNum, g.ENum = <span style=color:#666>7</span>, <span style=color:#666>12</span>
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; <span style=color:#666>8</span>; i<span style=color:#666>++</span> {
		<span style=color:#080;font-style:italic>//为了便于操作和理解，从下标为1开始
</span><span style=color:#080;font-style:italic></span>		g.AdjMatrix = <span style=color:#a2f>append</span>(g.AdjMatrix, <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>8</span>))
	}
	g.AdjMatrix[<span style=color:#666>1</span>][<span style=color:#666>2</span>], g.AdjMatrix[<span style=color:#666>1</span>][<span style=color:#666>4</span>] = <span style=color:#666>2</span>, <span style=color:#666>1</span>
	g.AdjMatrix[<span style=color:#666>2</span>][<span style=color:#666>4</span>], g.AdjMatrix[<span style=color:#666>2</span>][<span style=color:#666>5</span>] = <span style=color:#666>3</span>, <span style=color:#666>10</span>
	g.AdjMatrix[<span style=color:#666>3</span>][<span style=color:#666>1</span>], g.AdjMatrix[<span style=color:#666>3</span>][<span style=color:#666>6</span>] = <span style=color:#666>4</span>, <span style=color:#666>5</span>
	g.AdjMatrix[<span style=color:#666>4</span>][<span style=color:#666>3</span>], g.AdjMatrix[<span style=color:#666>4</span>][<span style=color:#666>5</span>], g.AdjMatrix[<span style=color:#666>4</span>][<span style=color:#666>6</span>], g.AdjMatrix[<span style=color:#666>4</span>][<span style=color:#666>7</span>] = <span style=color:#666>2</span>, <span style=color:#666>2</span>, <span style=color:#666>8</span>, <span style=color:#666>4</span>
	g.AdjMatrix[<span style=color:#666>5</span>][<span style=color:#666>7</span>] = <span style=color:#666>6</span>
	g.AdjMatrix[<span style=color:#666>7</span>][<span style=color:#666>6</span>] = <span style=color:#666>1</span>
	<span style=color:#a2f;font-weight:700>return</span> g
}
</code></pre></div><h2 id=4-图的遍历>4. 图的遍历</h2><p>有深度优先（Depth First Search, DFS）和广度优先（Breadth First Search, BFS）两种，前者类似于树的先序遍历，后者类似于树的层次遍历。下面图的遍历算法以下图为例</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd-1585138053043.png alt=图的邻接矩阵表示></p><h3 id=41-深度优先遍历>4.1 深度优先遍历</h3><p>递归解法的程序实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>DepthFirstSearch</span>(g <span style=color:#666>*</span>Graph, vertex <span style=color:#0b0;font-weight:700>int</span>, result []<span style=color:#0b0;font-weight:700>int</span>) []<span style=color:#0b0;font-weight:700>int</span> {
	g.AdjMatrix[<span style=color:#666>0</span>][vertex] = <span style=color:#666>1</span>
	result = <span style=color:#a2f>append</span>(result, vertex)
	<span style=color:#a2f;font-weight:700>for</span> k, v <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> g.AdjMatrix[vertex] {
		<span style=color:#a2f;font-weight:700>if</span> v &gt; <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> g.AdjMatrix[<span style=color:#666>0</span>][k] <span style=color:#666>!=</span> <span style=color:#666>1</span> {
			result = <span style=color:#00a000>DepthFirstSearch</span>(g, k, result)
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> result
}
</code></pre></div><p>以结点0为入口，深度优先的遍历结果为[0 1 4 2 5 3]</p><h3 id=42-广度优先遍历>4.2 广度优先遍历</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>BreadthFirstSearch</span>(g <span style=color:#666>*</span>Graph, vertex <span style=color:#0b0;font-weight:700>int</span>) []<span style=color:#0b0;font-weight:700>int</span> {
	result <span style=color:#666>:=</span> []<span style=color:#0b0;font-weight:700>int</span>{}
	g.AdjMatrix[<span style=color:#666>0</span>][vertex] = <span style=color:#666>1</span>
	queue <span style=color:#666>:=</span> list.<span style=color:#00a000>New</span>()
	queue.<span style=color:#00a000>PushBack</span>(vertex)
	<span style=color:#a2f;font-weight:700>for</span> queue.<span style=color:#00a000>Len</span>() <span style=color:#666>!=</span> <span style=color:#666>0</span> {
		vertex <span style=color:#666>:=</span> queue.<span style=color:#00a000>Remove</span>(queue.<span style=color:#00a000>Front</span>()).(<span style=color:#0b0;font-weight:700>int</span>)
		result = <span style=color:#a2f>append</span>(result, vertex)
		<span style=color:#a2f;font-weight:700>for</span> k, v <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> g.AdjMatrix[vertex] {
			<span style=color:#a2f;font-weight:700>if</span> v &gt; <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> g.AdjMatrix[<span style=color:#666>0</span>][k] <span style=color:#666>!=</span> <span style=color:#666>1</span> {
				g.AdjMatrix[<span style=color:#666>0</span>][k] = <span style=color:#666>1</span>
				queue.<span style=color:#00a000>PushBack</span>(k)
			}
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> result
}
</code></pre></div><p>以结点0为入口，广度优先的遍历结果为[0 1 2 3 4 5]</p><h2 id=5-最短路径>5. 最短路径</h2><p>最短路径问题可以抽象为：在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径，这条路径就是两点之间的最短路径（Shortest Path）。其中，第一个顶点为源点（Source），最后一个顶点为终点（Destination）。</p><p>最短路径问题不是一个单独的问题，而是一系列问题的综合，包括</p><ol><li>单源最短路径问题：从某固定源点出发，求其到所有其它顶点的最短路径<ul><li>（有向）无权图</li><li>（有向）有权图</li></ul></li><li>多源最短路径问题：求任意两顶点间的最短路径</li></ol><p>最短路径使用的示例图如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png alt></p><h3 id=51-单源最短路径>5.1 单源最短路径</h3><p>在理解最短路径算法前有两个问题需要注意</p><ol><li>无向图和有向图都适用，虽然多数示例是有向图</li><li>无权图是有权图的特例（权值为1），因此不单独介绍</li><li>图中不可以存在权值为负的边，否则 Dijkstra(迪杰斯特拉)算法不起作用</li></ol><p>如第3条所述，单源最短路径的典型算法称为 Dijkstra(迪杰斯特拉)算法，算法的基本思想为以起始点为中心层层向外扩展，直到扩展到终点为止。因此，该算法和广度优先搜索有一定的相似性。</p><p>输入上面的示例图，Dijkstra算法的输出为：[0 2 3 1 3 6 5]</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>DijkstraShortestPath</span>(g <span style=color:#666>*</span>Graph, vertex <span style=color:#0b0;font-weight:700>int</span>) {
	count <span style=color:#666>:=</span> <span style=color:#666>1</span>                          <span style=color:#080;font-style:italic>// 已收录的顶点数目，用于控制循环
</span><span style=color:#080;font-style:italic></span>	find <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>bool</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>)      <span style=color:#080;font-style:italic>//标记已访问过的结点
</span><span style=color:#080;font-style:italic></span>	prevVertex <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>) <span style=color:#080;font-style:italic>//当前节点的前驱结点
</span><span style=color:#080;font-style:italic></span>	distance <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>)   <span style=color:#080;font-style:italic>//当前结点的最短路径
</span><span style=color:#080;font-style:italic></span>
	<span style=color:#080;font-style:italic>//初始化
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> g.VNum; i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>if</span> g.AdjMatrix[vertex][i] &gt; <span style=color:#666>0</span> {
			distance[i] = g.AdjMatrix[vertex][i]
			prevVertex[i] = vertex
		} <span style=color:#a2f;font-weight:700>else</span> {
			distance[i] = MAX_INT
			prevVertex[i] = <span style=color:#666>-</span><span style=color:#666>1</span>
		}
	}

	distance[vertex] = <span style=color:#666>0</span>
	find[vertex] = <span style=color:#a2f;font-weight:700>true</span>
	v, d <span style=color:#666>:=</span> vertex, <span style=color:#666>0</span> <span style=color:#080;font-style:italic>//用来迭代顶点的变量和初始距离
</span><span style=color:#080;font-style:italic></span>
	<span style=color:#a2f;font-weight:700>for</span> count &lt; g.VNum {
		d = MAX_INT
		<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> g.VNum; i<span style=color:#666>++</span> {
			<span style=color:#a2f;font-weight:700>if</span> !find[i] <span style=color:#666>&amp;&amp;</span> distance[i] &lt; d {
				d = distance[i]
				v = i
			}
		}
		find[v] = <span style=color:#a2f;font-weight:700>true</span>
		count<span style=color:#666>++</span>
		<span style=color:#a2f;font-weight:700>for</span> k, t <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> g.AdjMatrix[v] {
			<span style=color:#a2f;font-weight:700>if</span> !find[k] <span style=color:#666>&amp;&amp;</span> t &gt; <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> distance[v]<span style=color:#666>+</span>t &lt; distance[k] {
				distance[k] = distance[v] <span style=color:#666>+</span> t
				prevVertex[k] = v
			}
		}

	}
	fmt.<span style=color:#00a000>Println</span>(distance[<span style=color:#666>1</span>:])
}
</code></pre></div><h3 id=52-多源最短路径>5.2 多源最短路径</h3><p>多源最短路径使用Floyd算法，这是一个经典的动态规划算法，核心思想是：从任意节点 i 到任意节点 j 的最短路径不外乎2种可能，1是直接从 i 到 j，2是从 i 经过若干个节点 k 到 j。所以，我们假设 Distance(i,j) 为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查 Distance(i,k) + Distance(k,j) &lt; Distance(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置Distance(i,j) = Distance(i,k) + Distance(k,j)，这样一来，当我们遍历完所有节点 k，Distance(i,j) 中记录的便是 i 到 j 的最短路径的距离。</p><p>整个过程可以描述为两个步骤</p><ol><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是，更新它。</li></ol><p>程序实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>FloydShortestPath</span>(g <span style=color:#666>*</span>Graph, vertex <span style=color:#0b0;font-weight:700>int</span>) {
	<span style=color:#a2f;font-weight:700>var</span> D [][]<span style=color:#0b0;font-weight:700>int</span>
	<span style=color:#a2f;font-weight:700>var</span> path [][]<span style=color:#0b0;font-weight:700>int</span>
	<span style=color:#a2f;font-weight:700>var</span> i, j, k <span style=color:#0b0;font-weight:700>int</span>
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; g.VNum; i<span style=color:#666>++</span> {
		D = <span style=color:#a2f>append</span>(D, <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum))
		path = <span style=color:#a2f>append</span>(path, <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum))
	}
	<span style=color:#a2f;font-weight:700>for</span> i = <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> g.VNum; i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>for</span> j = <span style=color:#666>1</span>; j &lt; g.VNum; j<span style=color:#666>++</span> {
			D[i][j] = g.AdjMatrix[i][j]
			path[i][j] = <span style=color:#666>-</span><span style=color:#666>1</span>
		}
	}
	<span style=color:#a2f;font-weight:700>for</span> k = <span style=color:#666>1</span>; k <span style=color:#666>&lt;=</span> g.VNum; k<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>for</span> i = <span style=color:#666>0</span>; i &lt; g.VNum; i<span style=color:#666>++</span> {
			<span style=color:#a2f;font-weight:700>if</span> D[i][k]<span style=color:#666>+</span>D[k][i] &lt; D[i][j] {
				D[i][j] = D[i][k] <span style=color:#666>+</span> D[k][j]
				path[i][j] = k
			}
		}
	}
}
</code></pre></div><h2 id=6-拓扑排序>6. 拓扑排序</h2><p>如果图中从 v 到 w 有一条有向路径，则 v 一定排在 w 之前。满足此条件的顶点序列称为一个<strong>拓扑序</strong>，获得一个拓扑序的过程就是<strong>拓扑排序</strong>。</p><p>一个最典型的例子是排课表，一个专业很多课程都有先修课，因此排课时必须考虑先修课的存在，以每门课程为结点，若课程间存在先修课关系则有边，这样构成的网络叫做AOV（Activity On Vertex）网，也是拓扑排序使用的网络。</p><p>拓扑排序用一句话描述就是「每次删除入度为0的顶点并输出它」，以下图为例，拓扑排序的结果为：V1,V2,V3,V4,V5。拓扑排序的结果是不唯一的。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yKVYt.png alt=拓扑排序></p><p>拓扑排序必定是一个有向无环图（DAG），因此，该算法也可以用于判断一个图是否为有向无环图。程序实现如下，返回的result是拓扑排序结果，ve是关键路径需要用到的事件最早发生时间。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>TopologicalSort</span>(g <span style=color:#666>*</span>Graph) ([]<span style=color:#0b0;font-weight:700>int</span>, []<span style=color:#0b0;font-weight:700>int</span>) {
	result <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>1</span>) <span style=color:#080;font-style:italic>//拓扑排序的结果数组
</span><span style=color:#080;font-style:italic></span>	ve <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>)
	count <span style=color:#666>:=</span> <span style=color:#666>0</span> <span style=color:#080;font-style:italic>//判断图中是否有环
</span><span style=color:#080;font-style:italic></span>
	<span style=color:#080;font-style:italic>//计算各结点的入度并存储
</span><span style=color:#080;font-style:italic></span>	indegree <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>)
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> g.VNum; i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>for</span> j <span style=color:#666>:=</span> <span style=color:#666>1</span>; j <span style=color:#666>&lt;=</span> g.VNum; j<span style=color:#666>++</span> {
			<span style=color:#a2f;font-weight:700>if</span> g.AdjMatrix[i][j] &gt; <span style=color:#666>0</span> {
				indegree[j]<span style=color:#666>++</span>
			}
		}
	}

	queue <span style=color:#666>:=</span> list.<span style=color:#00a000>New</span>()

	<span style=color:#080;font-style:italic>//入度为0的结点入队
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> g.VNum; i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>if</span> indegree[i] <span style=color:#666>==</span> <span style=color:#666>0</span> {
			queue.<span style=color:#00a000>PushBack</span>(i)
		}
	}

	<span style=color:#a2f;font-weight:700>for</span> queue.<span style=color:#00a000>Len</span>() <span style=color:#666>!=</span> <span style=color:#666>0</span> {
		vertex <span style=color:#666>:=</span> queue.<span style=color:#00a000>Remove</span>(queue.<span style=color:#00a000>Front</span>()).(<span style=color:#0b0;font-weight:700>int</span>)
		result = <span style=color:#a2f>append</span>(result, vertex)
		count<span style=color:#666>++</span>
		<span style=color:#a2f;font-weight:700>for</span> k, v <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> g.AdjMatrix[vertex] {
			<span style=color:#a2f;font-weight:700>if</span> v &gt; <span style=color:#666>0</span> {
				indegree[k]<span style=color:#666>--</span>
				<span style=color:#a2f;font-weight:700>if</span> indegree[k] <span style=color:#666>==</span> <span style=color:#666>0</span> {
					queue.<span style=color:#00a000>PushBack</span>(k)
				}
				<span style=color:#a2f;font-weight:700>if</span> ve[vertex]<span style=color:#666>+</span>v &gt; ve[k] {
					ve[k] = ve[vertex] <span style=color:#666>+</span> v
				}
			}
			<span style=color:#a2f;font-weight:700>if</span> v <span style=color:#666>==</span> <span style=color:#666>0</span> {
				<span style=color:#a2f;font-weight:700>if</span> ve[vertex]<span style=color:#666>+</span>v &gt; ve[k] {
					ve[k] = ve[vertex] <span style=color:#666>+</span> v
				}
			}
		}
	}
	<span style=color:#a2f;font-weight:700>if</span> count <span style=color:#666>!=</span> g.VNum {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;This is a DAG!&#34;</span>)
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>, <span style=color:#a2f;font-weight:700>nil</span>
	}
	<span style=color:#a2f;font-weight:700>return</span> result, ve
}
</code></pre></div><h2 id=7-关键路径>7. 关键路径</h2><p>拓扑排序应用在AOV网络上，每个顶点表示一个活动或任务。如果每条边表示一个活动或任务，就是AOE（Activity On Edge）网络，多用在安排一个庞大生产流程的工序上，工序之间有先后关系。</p><p>如下图所示，在AOE网络中，事件 i 发生后，其后继活动 a(i,*) 都可以开始，但只有所有先导活动 a( *,j ) 都结束后，事件 j 才可以发生。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png alt></p><p>假设一个工程的 AOE 网如下，最常求的就是 a) 整个工程完工需要多长时间？ b) 哪些活动影响工程进度？或求关键路径。图中的虚线表示事件有先后关系，但是这个活动不存在。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y3Exx.png alt=AOE网络></p><p>对事件（顶点）i，令最早发生时间为 ve(i)，最晚发生时间为 vl(i)；</p><p>对活动（边）a(i,j)，令最早开始时间为 e(i,j)，最晚开始时间为 l(i,j)。</p><p>那么整个工程的完工时间就是终点的最早发生时间；关键路径就是路径长度最长的路径。求关键路径的算法如下：</p><ol><li>将所有顶点进行拓扑排序；</li><li>计算 ve(j)， $ve(j) = max{ve(<em>) + a(</em>,j)}$ ，其中*为任意前驱事件，有ve(1) = 0；</li><li>计算 vl(i)， $vl(i) = min{vl(<em>) - a(i,</em>)}$ ，其中*为任意后继事件，有vl(n) = ve(n)；</li><li>计算 e(i,j) 和 l(i,j)，$e(i,j) = ve(i)$，$l(i,j) = vl(j)-a(i,j)$</li><li>结论：工程总用时 ve(n)，关键活动是 e(i,j) = l(i,j) 的活动 a(i,j)</li></ol><p>如果只求工程总用时，那么只需要第1，2步。关于两个核心公式可以这样理解：事件 j 在所有前驱活动都完成后发生，所以其最早发生时间为 $ve(j) = max{ve(<em>) + a(</em>,j)}$ ，即取决于最慢的前驱活动。另一方面，事件 i 发生后所有后继活动都可以开始了，所以其最晚发生时间为 $vl(i) = min{vl(<em>) - a(i,</em>)}$，即不耽误最慢的后继活动。</p><p>简单理解的话，就是按照拓扑有序排列顶点，然后从前往后计算事件的最早发生时间得到总时间，再从后往前计算事件的最晚发生时间，最后计算活动的最早和最晚开始时间得到关键活动和关键路径。求上面示例图的关键路径过程如下表</p><table><thead><tr><th>事件</th><th>最早发生时间ve</th><th>最晚发生时间vl</th><th>活动</th><th>最早开始时间e</th><th>最晚开始时间l</th></tr></thead><tbody><tr><td>v1</td><td>0</td><td>0</td><td>a(1,2)</td><td>0</td><td>0</td></tr><tr><td>v2</td><td>6</td><td>6</td><td>a(1,3)</td><td>0</td><td>2</td></tr><tr><td>v3</td><td>4</td><td>6</td><td>a(1,4)</td><td>0</td><td>1</td></tr><tr><td>v4</td><td>5</td><td>6</td><td>a(2,5)</td><td>6</td><td>6</td></tr><tr><td>v5</td><td>7</td><td>7</td><td>a(3,5)</td><td>4</td><td>6</td></tr><tr><td>v6</td><td>7</td><td>7</td><td>a(4,6)</td><td>5</td><td>6</td></tr><tr><td>v7</td><td>12</td><td>13</td><td>a(5,6)</td><td>7</td><td>7</td></tr><tr><td>v8</td><td>11</td><td>11</td><td>a(5,7)</td><td>7</td><td>8</td></tr><tr><td>v9</td><td>15</td><td>15</td><td>a(5,8)</td><td>7</td><td>8</td></tr><tr><td></td><td></td><td></td><td>a(6,8)</td><td>7</td><td>7</td></tr><tr><td></td><td></td><td></td><td>a(7,9)</td><td>12</td><td>13</td></tr><tr><td></td><td></td><td></td><td>a(8,9)</td><td>11</td><td>11</td></tr></tbody></table><p>最终得到工程完工需要时间为15，关键路径是 1,2,5,6,8,9</p><p>程序实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func CriticalPath(g *Graph) (int, []int) {
	path, ve := TopologicalSort(g)
	if len(path) == 1 || path == nil {
		return 0, nil
	}
	vl := make([]int, len(path))
	for i := 1; i &lt; len(vl); i++ {
		vl[i] = MAX_INT
	}
	vl[len(ve)-1] = ve[len(ve)-1]

	for i := len(vl) - 2; i &gt; 0; i-- {
		for k, v := range g.AdjMatrix[i] {
			if v &gt;= 0 &amp;&amp; vl[k]-v &lt; vl[i] {
				vl[i] = vl[k] - v
			}
		}
	}
	result := []int{}
	for i := 1; i &lt; g.VNum+1; i++ {
		for j := 1; j &lt; g.VNum+1; j++ {
			if g.AdjMatrix[i][j] &gt;= 0 {
				if ve[i] == vl[j]-g.AdjMatrix[i][j] {
					result = append(result, i)
				}
			}
		}
	}
	result = append(result, path[len(path)-1])
	return ve[len(ve)-1], result
}
</code></pre></div><h2 id=8-最小生成树>8. 最小生成树</h2><p>生成树指包含全部顶点且树的 V-1 条边全部在图里的树，其中 V 为顶点数目。最小生成树（Minimum Spanning Tree）就是边的权重和最小的生成树。需要注意两点</p><ol><li>向生成树中任加一条边都一定会构成回路</li><li>最小生成树存在等价于图连通</li></ol><p>生成最小生成树最常见的有 Prim 和 Kruskal 两种算法，这两种都是贪心算法。</p><h3 id=81-kruskal算法>8.1 Kruskal算法</h3><p>算法的核心思想用一句话描述就是「不构成环的情况下，每次选取最小的边」，最小边的选取可以使用最小堆，环的判断可以使用并查集。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IP2RI.png alt=Kruskal算法></p><p>代码实现如下，最小堆的实现使用了 标准库中的container/heap，usetFind是并查集的查找函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>usetFind</span>(x <span style=color:#0b0;font-weight:700>int</span>, uset []<span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>for</span> x <span style=color:#666>!=</span> uset[x] {
		x = uset[x]
	}
	<span style=color:#a2f;font-weight:700>return</span> x
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>KruskalMiniSpanTree</span>(g <span style=color:#666>*</span>Graph) (<span style=color:#0b0;font-weight:700>int</span>, []<span style=color:#0b0;font-weight:700>int</span>) {
	<span style=color:#a2f;font-weight:700>var</span> total <span style=color:#0b0;font-weight:700>int</span>
	result <span style=color:#666>:=</span> []Edge{}
	h <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>Heap{}
	heap.<span style=color:#00a000>Init</span>(h)

	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>; i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>for</span> j <span style=color:#666>:=</span> i; j &lt; g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>; j<span style=color:#666>++</span> {
			<span style=color:#a2f;font-weight:700>if</span> g.AdjMatrix[i][j] &gt; <span style=color:#666>0</span> {
				heap.<span style=color:#00a000>Push</span>(h, Edge{i, j, g.AdjMatrix[i][j]})
			}
		}
	}

	uset <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>) <span style=color:#080;font-style:italic>//用数组表示并查集
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#a2f>len</span>(uset); i<span style=color:#666>++</span> {
		uset[i] = i
	}

	<span style=color:#a2f;font-weight:700>for</span> h.<span style=color:#00a000>Len</span>() <span style=color:#666>!=</span> <span style=color:#666>0</span> {
		e <span style=color:#666>:=</span> heap.<span style=color:#00a000>Pop</span>(h).(Edge)
		<span style=color:#a2f;font-weight:700>if</span> <span style=color:#00a000>usetFind</span>(e.from, uset) <span style=color:#666>!=</span> <span style=color:#00a000>usetFind</span>(e.to, uset) {
			result = <span style=color:#a2f>append</span>(result, e)
			uset[uset[e.to]] = uset[e.from]
			total <span style=color:#666>+=</span> e.weight
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> total, uset
}
</code></pre></div><h3 id=82-prim算法>8.2 Prim算法</h3><p>记 V 是联通网的顶点集，U 是求得的生成树的顶点集，TE 是求得的生成树的边集。普利姆算法步骤如下</p><ol><li>开始时，$U={v_0}, TE = \emptyset$</li><li>计算 U 到其余顶点 V-U 的最小代价，将该顶点纳入 U，边纳入TE</li><li>重复第二步直到 U=V</li></ol><p>一个例子如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IFD4H.png alt=Prim算法></p><p>代码实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>PrimMiniSpanTree</span>(g <span style=color:#666>*</span>Graph, start <span style=color:#0b0;font-weight:700>int</span>) (<span style=color:#0b0;font-weight:700>int</span>, []<span style=color:#0b0;font-weight:700>int</span>) {
	total <span style=color:#666>:=</span> <span style=color:#666>0</span>
	parent <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>)
	dist <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, g.VNum<span style=color:#666>+</span><span style=color:#666>1</span>)

	parent[start] = <span style=color:#666>-</span><span style=color:#666>1</span>

	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#a2f>len</span>(dist); i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>if</span> i <span style=color:#666>==</span> start {
			<span style=color:#a2f;font-weight:700>continue</span>
		}
		<span style=color:#a2f;font-weight:700>if</span> g.AdjMatrix[start][i] &gt; <span style=color:#666>0</span> {
			dist[i] = g.AdjMatrix[start][i]
		} <span style=color:#a2f;font-weight:700>else</span> {
			dist[i] = MAX_INT
		}
	}

	count <span style=color:#666>:=</span> <span style=color:#666>1</span>
	vertex, mini <span style=color:#666>:=</span> start, MAX_INT

	<span style=color:#a2f;font-weight:700>for</span> count &lt; g.VNum {
		mini = MAX_INT
		<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#a2f>len</span>(dist); i<span style=color:#666>++</span> {
			<span style=color:#a2f;font-weight:700>if</span> dist[i] <span style=color:#666>!=</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> dist[i] &lt; mini {
				vertex, mini = i, dist[i]
			}
		}

		total <span style=color:#666>+=</span> dist[vertex]
		dist[vertex] = <span style=color:#666>0</span>
		count<span style=color:#666>++</span>

		<span style=color:#a2f;font-weight:700>for</span> k, t <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> g.AdjMatrix[vertex] {
			<span style=color:#a2f;font-weight:700>if</span> dist[k] <span style=color:#666>!=</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> t &gt; <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> t &lt; dist[k] {
				dist[k] = t
				parent[k] = vertex
			}
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> total, parent
}
</code></pre></div><h3 id=83-两种算法比较>8.3 两种算法比较</h3><p>Kruskal的算法时间复杂度为$O(eloge)$，只和边的数目 e 有关，与顶点个数 n 无关，适用于稀疏图</p><p>Prim算法时间复杂度为$O(n^2)$，只和顶点个数 n 有关，与边的数目 e 无关，适用于稠密图</p></div><footer class=post-footer><div class=post-tags><a href=/tags/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95 rel=tag title=数据结构与算法>#数据结构与算法#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>声明：</span>数据结构-图</p><p><span>链接：</span>https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/data-structure-graph/</p><p><span>作者：</span>书藏</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/data-structure-b-tree-and-red-black-tree/ rel=next title=数据结构-B树与红黑树><i class="fa fa-chevron-left"></i>数据结构-B树与红黑树</a></div><div class="post-nav-prev post-nav-item"><a href=https://shuzang.github.io/post/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/what-can-blockchain-do-during-the-covid-19/ rel=prev title=面对疫情区块链可以做些什么>面对疫情区块链可以做些什么
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://www.ucloud.cn/ style=font-weight:700 target=_blank>UCloud云存储</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href target=_blank></a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer();});</script><script type=text/javascript>$(function(){if(detectIE()>0){$.getScript(document.location.protocol+'//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',function(){new Waline({el:'#wcomments',visitor:true,avatar:'wavatar',avatarCDN:'https://sdn.geekzu.org/avatar/',avatarForce:!1,wordLimit:'200',placeholder:' 欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^ ',requiredFields:['nick','mail'],serverURL:"Your WalineSerURL",lang:"zh-cn"});});}else{$('#wcomments').html('抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。');}});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>
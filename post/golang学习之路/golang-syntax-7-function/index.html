<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Golang语法基础7-函数 - 书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="Golang语法基础7-函数"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/author.jpg"><meta name=title content="Golang语法基础7-函数 - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/golang-syntax-7-function/ itemprop=url>Golang语法基础7-函数</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2019-11-25">2019-11-25</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF itemprop=url rel=index style=text-decoration:underline><span itemprop=name>Golang学习之路</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>3675 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>8分钟</span></span>
<span id=/post/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/golang-syntax-7-function/ class=leancloud_visitors data-flag-title=Golang语法基础7-函数>|
<i class="fa fa-binoculars fa-fw"></i><span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><h2 id=1-函数声明与定义>1. 函数声明与定义</h2><p>Go中有三种类型的函数：</p><ol><li>普通的带有名字的函数</li><li>匿名函数</li><li>方法（Methods，在结构体部分介绍）</li></ol><p>普通函数声明的基本格式为</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>functionName</span>(param1 type1, param2 type2,<span style=color:#666>...</span>) (ret1 type1, ret2 type2,<span style=color:#666>...</span>)
</code></pre></div><p>定义就需要添加大括号和函数体</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>functionName</span>(param1 type1, param2 type2,<span style=color:#666>...</span>) (ret1 type1, ret2 type2,<span style=color:#666>...</span>) {
    <span style=color:#666>...</span>
}
</code></pre></div><p>两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。</p><p>当函数执行到代码块最后一行，也就是最后一个<code>}</code>之前，或者执行到<code>return</code>语句的时候就会退出。</p><p>main函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有init()函数会先执行该函数。</p><p>main函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main函数一旦返回就表示程序已成功执行并立即退出。同样，init()函数也没有返回值</p><h2 id=2-函数调用>2. 函数调用</h2><p>同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>pack1.<span style=color:#00a000>functionName</span>(arg1, arg2, <span style=color:#666>...</span>, argn)
</code></pre></div><p><code>pack1</code>是包名，<code>functionName</code>是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    <span style=color:#a2f>println</span>(<span style=color:#b44>&#34;In main before calling greeting&#34;</span>)
    <span style=color:#00a000>greeting</span>()
    <span style=color:#a2f>println</span>(<span style=color:#b44>&#34;In main after calling greeting&#34;</span>)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>greeting</span>() {
    <span style=color:#a2f>println</span>(<span style=color:#b44>&#34;In greeting: Hi!!!!!&#34;</span>)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>In main before calling greeting
In greeting: Hi!!!!!
In main after calling greeting
</code></pre></div><p>Go中不允许函数重载</p><h2 id=3-函数参数与返回值>3. 函数参数与返回值</h2><p>除了mian()和init()函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以<code>return</code>或<code>panic</code>语句结尾，<code>return</code>可以返回多个值，多值返回是Go的一大特性。</p><h3 id=31-参数传递类型>3.1 参数传递类型</h3><p>Go中的参数传递类型有两种：按值传递和按引用传递。</p><p>Go默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符&，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。</p><p>函数调用时，切片、映射、接口、通道这些引用类型默认使用按引用传递</p><p>几乎在任何情况下，按引用传递的消耗都比按值传递小</p><p>按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用<code>return</code>返回</p><h3 id=32-命名参数>3.2 命名参数</h3><p>函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如<code>func f(int, int, float64)</code>，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>var</span> num <span style=color:#0b0;font-weight:700>int</span> = <span style=color:#666>10</span>
<span style=color:#a2f;font-weight:700>var</span> numx2, numx3 <span style=color:#0b0;font-weight:700>int</span>

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    numx2, numx3 = <span style=color:#00a000>getX2AndX3</span>(num)
    <span style=color:#00a000>PrintValues</span>()
    numx2, numx3 = <span style=color:#00a000>getX2AndX3_2</span>(num)
    <span style=color:#00a000>PrintValues</span>()
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>PrintValues</span>() {
    fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;num = %d, 2x num = %d, 3x num = %d\n&#34;</span>, num, numx2, numx3)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>getX2AndX3</span>(input <span style=color:#0b0;font-weight:700>int</span>) (<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#0b0;font-weight:700>int</span>) {
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>2</span> <span style=color:#666>*</span> input, <span style=color:#666>3</span> <span style=color:#666>*</span> input
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>getX2AndX3_2</span>(input <span style=color:#0b0;font-weight:700>int</span>) (x2 <span style=color:#0b0;font-weight:700>int</span>, x3 <span style=color:#0b0;font-weight:700>int</span>) {
    x2 = <span style=color:#666>2</span> <span style=color:#666>*</span> input
    x3 = <span style=color:#666>3</span> <span style=color:#666>*</span> input
    <span style=color:#080;font-style:italic>// return x2, x3
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>return</span>
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>num = <span style=color:#666>10</span>, <span style=color:#666>2</span>x num = <span style=color:#666>20</span>, <span style=color:#666>3</span>x num = <span style=color:#666>30</span>    
num = <span style=color:#666>10</span>, <span style=color:#666>2</span>x num = <span style=color:#666>20</span>, <span style=color:#666>3</span>x num = <span style=color:#666>30</span> 
</code></pre></div><p>命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的return语句（带参数也不会出错）。</p><p>当需要返回多个非命名返回值时，需要使用括号包围，如<code>(int, int)</code>，但对命名返回值，即使只有一个返回值，也要用括号包围。</p><h3 id=33-空白符>3.3 空白符</h3><p>空白符<code>_</code>用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。</p><h3 id=34-变长参数>3.4 变长参数</h3><p>如果函数最后一个参数是<code>...type</code>的形式，那么函数就可以处理一个变长的参数，这个长度可以是0，这样的函数称为变参函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>myFunc</span>(a, b, arg <span style=color:#666>...</span><span style=color:#0b0;font-weight:700>int</span>) {}
</code></pre></div><p>变长参数的本质是一个切片，如下例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Greeting</span>(prefix <span style=color:#0b0;font-weight:700>string</span>, who <span style=color:#666>...</span><span style=color:#0b0;font-weight:700>string</span>)
<span style=color:#00a000>Greeting</span>(<span style=color:#b44>&#34;hello:&#34;</span>, <span style=color:#b44>&#34;Joe&#34;</span>, <span style=color:#b44>&#34;Anna&#34;</span>, <span style=color:#b44>&#34;Eileen&#34;</span>)
</code></pre></div><p>变量<code>who</code>的值为 <code>[]string{"Joe", "Anna", "Eileen"}</code></p><p>如果参数本身就存在一个切片类型中，比如切片<code>slice1</code>，则可以通过<code>slice1...</code>的形式传递参数，之前的切片部分使用append函数时已经这样使用过</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	x <span style=color:#666>:=</span> <span style=color:#00a000>min</span>(<span style=color:#666>1</span>, <span style=color:#666>3</span>, <span style=color:#666>2</span>, <span style=color:#666>0</span>)
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The minimum is: %d\n&#34;</span>, x)
	slice <span style=color:#666>:=</span> []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>7</span>,<span style=color:#666>9</span>,<span style=color:#666>3</span>,<span style=color:#666>5</span>,<span style=color:#666>1</span>}
	x = <span style=color:#00a000>min</span>(slice<span style=color:#666>...</span>)
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The minimum in the slice is: %d&#34;</span>, x)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>min</span>(s <span style=color:#666>...</span><span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>if</span> <span style=color:#a2f>len</span>(s)<span style=color:#666>==</span><span style=color:#666>0</span> {
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>
	}
	min <span style=color:#666>:=</span> s[<span style=color:#666>0</span>]
	<span style=color:#a2f;font-weight:700>for</span> _, v <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> s {
		<span style=color:#a2f;font-weight:700>if</span> v &lt; min {
			min = v
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> min
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>The minimum is: <span style=color:#666>0</span>
The minimum in the slice is: <span style=color:#666>1</span>
</code></pre></div><p>一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>F1</span>(s <span style=color:#666>...</span><span style=color:#0b0;font-weight:700>string</span>) {
	<span style=color:#00a000>F2</span>(s<span style=color:#666>...</span>)
	<span style=color:#00a000>F3</span>(s)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>F2</span>(s <span style=color:#666>...</span><span style=color:#0b0;font-weight:700>string</span>) { }
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>F3</span>(s []<span style=color:#0b0;font-weight:700>string</span>) { }
</code></pre></div><h3 id=35-函数作为参数>3.5 函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要函数返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#00a000>callback</span>(<span style=color:#666>1</span>, Add)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Add</span>(a, b <span style=color:#0b0;font-weight:700>int</span>) {
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The sum of %d and %d is: %d\n&#34;</span>, a, b, a<span style=color:#666>+</span>b)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>callback</span>(y <span style=color:#0b0;font-weight:700>int</span>, f <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#0b0;font-weight:700>int</span>)) {
	<span style=color:#00a000>f</span>(y, <span style=color:#666>2</span>) <span style=color:#080;font-style:italic>// this becomes Add(1, 2)
</span><span style=color:#080;font-style:italic></span>}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>The sum of <span style=color:#666>1</span> and <span style=color:#666>2</span> is: <span style=color:#666>3</span>
</code></pre></div><h2 id=4-内置函数>4. 内置函数</h2><p>Go语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如len, cap, append，以下是内置函数列表</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real imag</td><td>用于创建和操作复数</td></tr></tbody></table><h2 id=5-匿名函数与闭包>5. 匿名函数与闭包</h2><p>匿名函数是类似 <code>func(x, y int) int { return x + y }</code> 这样没有名字的函数。</p><p>匿名函数可以被直接调用，下面是一个计算从 1 到 1 百万整数的总和的匿名函数。表示参数列表的第一对括号必须紧挨着关键字 <code>func</code>，因为匿名函数没有名称。花括号 <code>{}</code> 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span>() {
	sum <span style=color:#666>:=</span> <span style=color:#666>0</span>
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> <span style=color:#666>1e6</span>; i<span style=color:#666>++</span> {
		sum <span style=color:#666>+=</span> i
	}
}()
</code></pre></div><p>另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (u <span style=color:#0b0;font-weight:700>string</span>) {
	fmt.<span style=color:#00a000>Println</span>(u)
	<span>…</span>
}(v)
</code></pre></div><p>还应该知道的，匿名函数可以被赋值给某个变量，如<code>fplus := func(x, y int) int { return x + y }</code>，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：<code>fplus(3, 4)</code></p><p>所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>f</span>(i <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#a2f;font-weight:700>func</span>() <span style=color:#0b0;font-weight:700>int</span> {
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>func</span>() <span style=color:#0b0;font-weight:700>int</span> {
        i<span style=color:#666>++</span>
        <span style=color:#a2f;font-weight:700>return</span> i
    }
}
</code></pre></div><p>在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 i，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#a2f;font-weight:700>var</span> f = <span style=color:#00a000>Adder</span>()
	fmt.<span style=color:#00a000>Print</span>(<span style=color:#00a000>f</span>(<span style=color:#666>1</span>), <span style=color:#b44>&#34; - &#34;</span>)
	fmt.<span style=color:#00a000>Print</span>(<span style=color:#00a000>f</span>(<span style=color:#666>20</span>), <span style=color:#b44>&#34; - &#34;</span>)
	fmt.<span style=color:#00a000>Print</span>(<span style=color:#00a000>f</span>(<span style=color:#666>300</span>))
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Adder</span>() <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>var</span> x <span style=color:#0b0;font-weight:700>int</span>
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>func</span>(delta <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
		x <span style=color:#666>+=</span> delta
		<span style=color:#a2f;font-weight:700>return</span> x
	}
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span><span style=color:#666>1</span> <span style=color:#666>-</span> <span style=color:#666>21</span> <span style=color:#666>-</span> <span style=color:#666>321</span>
</code></pre></div><p>从这里例子中我们注意到 x 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为函数被赋值给 f 之后，其实将整个闭包包括环境都赋值给了 f，变量 f 的生存周期内，其值是不变的，所以结果才会累积。</p><p>这种返回值为另一个函数的函数的形式也被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>MakeAddSuffix</span>(suffix <span style=color:#0b0;font-weight:700>string</span>) <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>func</span>(name <span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span> {
		<span style=color:#a2f;font-weight:700>if</span> !strings.<span style=color:#00a000>HasSuffix</span>(name, suffix) {
			<span style=color:#a2f;font-weight:700>return</span> name <span style=color:#666>+</span> suffix
		}
		<span style=color:#a2f;font-weight:700>return</span> name
	}
}
</code></pre></div><p>现在可以生成如下函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>addBmp <span style=color:#666>:=</span> <span style=color:#00a000>MakeAddSuffix</span>(<span style=color:#b44>&#34;.bmp&#34;</span>)
addJpeg <span style=color:#666>:=</span> <span style=color:#00a000>MakeAddSuffix</span>(<span style=color:#b44>&#34;.jpeg&#34;</span>)
</code></pre></div><p>然后调用它们</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00a000>addBmp</span>(<span style=color:#b44>&#34;file&#34;</span>) <span style=color:#080;font-style:italic>// returns: file.bmp
</span><span style=color:#080;font-style:italic></span><span style=color:#00a000>addJpeg</span>(<span style=color:#b44>&#34;file&#34;</span>) <span style=color:#080;font-style:italic>// returns: file.jpeg
</span></code></pre></div><h2 id=6-defer和追踪>6. defer和追踪</h2><p>关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种：</p><ol><li>包含 defer 语句的函数返回前</li><li>包含 defer 语句的函数执行到末尾</li><li>所在的 goroutine 发生 panic 时</li></ol><p>一个例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    <span style=color:#a2f;font-weight:700>defer</span> fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;Fourth&#34;</span>)
    fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;First&#34;</span>)
    fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;Third&#34;</span>)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>First
Third
Fourth
</code></pre></div><p>defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>i <span style=color:#666>:=</span> <span style=color:#666>1</span>
<span style=color:#a2f;font-weight:700>defer</span> fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;Deferred print:&#34;</span>, i)
i<span style=color:#666>++</span>
fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;Normal print:&#34;</span>, i)
<span style=color:#080;font-style:italic>// Output:
</span><span style=color:#080;font-style:italic></span>Normal print: <span style=color:#666>2</span>
Deferred print: <span style=color:#666>1</span>
</code></pre></div><p>但与匿名函数结合起来后，变量的值在函数运行时才会确定</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>f1</span>() (r <span style=color:#0b0;font-weight:700>int</span>) {
    r = <span style=color:#666>1</span>
    <span style=color:#a2f;font-weight:700>defer</span> <span style=color:#a2f;font-weight:700>func</span>() {
        r<span style=color:#666>++</span>
        fmt.<span style=color:#00a000>Println</span>(r)
    }()
    r = <span style=color:#666>2</span>
    <span style=color:#a2f;font-weight:700>return</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    <span style=color:#00a000>f1</span>()
}
<span style=color:#080;font-style:italic>// Output:
</span><span style=color:#080;font-style:italic></span><span style=color:#666>3</span>
</code></pre></div><p>上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事</p><ol><li>defer 函数执行时机是外层函数设置返回值之后，即将返回之前</li><li>return xxx 操作并不是原子的</li></ol><p>下面的例子中， return 0 实际上可以拆分为 r = 0; return 两条语句，因此输出是1不是0</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>f1</span>() (r <span style=color:#0b0;font-weight:700>int</span>) {
    <span style=color:#a2f;font-weight:700>defer</span> <span style=color:#a2f;font-weight:700>func</span>() {
        r<span style=color:#666>++</span>
    }()
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>
}
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    fmt.<span style=color:#00a000>Println</span>(<span style=color:#00a000>f1</span>())
}
</code></pre></div><p>来一个更复杂的例子</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>double</span>(x <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
    <span style=color:#a2f;font-weight:700>return</span> x <span style=color:#666>+</span> x
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>triple</span>(x <span style=color:#0b0;font-weight:700>int</span>) (r <span style=color:#0b0;font-weight:700>int</span>) {
    <span style=color:#a2f;font-weight:700>defer</span> <span style=color:#a2f;font-weight:700>func</span>() {
        r <span style=color:#666>+=</span> x
    }()
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>double</span>(x)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    fmt.<span style=color:#00a000>Println</span>(<span style=color:#00a000>triple</span>(<span style=color:#666>3</span>))
}
<span style=color:#080;font-style:italic>// Output:
</span><span style=color:#080;font-style:italic></span><span style=color:#666>9</span>
</code></pre></div><p>上面的例子实际上等价于</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>triple</span>(x <span style=color:#0b0;font-weight:700>int</span>) (r <span style=color:#0b0;font-weight:700>int</span>) {
    r = <span style=color:#00a000>double</span>(x)
    <span style=color:#a2f;font-weight:700>func</span>() {
        r <span style=color:#666>+=</span> x
    }()
    <span style=color:#a2f;font-weight:700>return</span>
}
</code></pre></div><p>多个 defer 同时使用时，以逆序执行，即后进先出</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>f</span>() {
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; <span style=color:#666>5</span>; i<span style=color:#666>++</span> {
		<span style=color:#a2f;font-weight:700>defer</span> fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;%d &#34;</span>, i)
	}
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span><span style=color:#666>4</span> <span style=color:#666>3</span> <span style=color:#666>2</span> <span style=color:#666>1</span> <span style=color:#666>0</span>
</code></pre></div><p>defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如</p><ol><li><p>关闭文件流</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>//open a file
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>defer</span> file.<span style=color:#00a000>Close</span>()
</code></pre></div></li><li><p>解锁一个加锁的资源</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>mu.<span style=color:#00a000>Lock</span>()
<span style=color:#a2f;font-weight:700>defer</span> mu.<span style=color:#00a000>Unlock</span>()
</code></pre></div></li><li><p>打印最终报告</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00a000>printHeader</span>()
<span style=color:#a2f;font-weight:700>defer</span> <span style=color:#00a000>printFooter</span>()
</code></pre></div></li><li><p>关闭数据库链接</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>//open a database connection
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>defer</span> <span style=color:#00a000>disconnectFromDB</span>()
</code></pre></div></li></ol><h2 id=7-编写规范>7. 编写规范</h2><p>Go是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是Uber开源在github的编码规范，有两条主要规则</p><ol><li><p>函数应按粗略的调用顺序排序</p></li><li><p>同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于<code>newXYZ()</code>这样的新建某个类型的函数。一个简单的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> something <span style=color:#a2f;font-weight:700>struct</span>{ <span style=color:#666>...</span> }
   
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>newSomething</span>() <span style=color:#666>*</span>something {
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>&amp;</span>something{}
}
   
<span style=color:#a2f;font-weight:700>func</span> (s <span style=color:#666>*</span>something) <span style=color:#00a000>Cost</span>() {
  <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>calcCost</span>(s.weights)
}
   
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>calcCost</span>(n []<span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {<span style=color:#666>...</span>}
</code></pre></div></li></ol><p>最后，main函数放在所有函数的最后。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/go%e8%af%ad%e6%b3%95 rel=tag title=Go语法>#Go语法#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>声明：</span>Golang语法基础7-函数</p><p><span>链接：</span>https://shuzang.github.io/post/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/golang-syntax-7-function/</p><p><span>作者：</span>书藏</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://shuzang.github.io/post/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/articles-about-blockchain/ rel=next title=区块链方向有参考价值的文章收集><i class="fa fa-chevron-left"></i>区块链方向有参考价值的文章收集</a></div><div class="post-nav-prev post-nav-item"><a href=https://shuzang.github.io/post/%E6%88%91%E6%89%80%E7%83%AD%E7%88%B1%E7%9A%84%E7%94%9F%E6%B4%BB%E5%95%8A/medicine-and-health-5-medical-insurance-and-medical-treatment/ rel=prev title=医药健康3-医保及就医>医药健康3-医保及就医
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://www.ucloud.cn/ style=font-weight:700 target=_blank>UCloud云存储</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href target=_blank></a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer();});</script><script type=text/javascript>$(function(){if(detectIE()>0){$.getScript(document.location.protocol+'//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',function(){new Waline({el:'#wcomments',visitor:true,avatar:'wavatar',avatarCDN:'https://sdn.geekzu.org/avatar/',avatarForce:!1,wordLimit:'200',placeholder:' 欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^ ',requiredFields:['nick','mail'],serverURL:"Your WalineSerURL",lang:"zh-cn"});});}else{$('#wcomments').html('抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。');}});</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>
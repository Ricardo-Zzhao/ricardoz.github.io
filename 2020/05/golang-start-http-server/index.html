<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Golang启动HTTP服务器 - 书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="Golang启动HTTP服务器"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/avatar.png"><meta name=title content="Golang启动HTTP服务器 - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/2020/05/golang-start-http-server/ itemprop=url>Golang启动HTTP服务器</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-05-29">2020-05-29</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF itemprop=url rel=index style=text-decoration:underline><span itemprop=name>Golang学习之路</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>4625 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>10分钟</span></span>
<span id=/2020/05/golang-start-http-server/ class=leancloud_visitors data-flag-title=Golang启动HTTP服务器>|
<i class="fa fa-binoculars fa-fw"></i><span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>本文介绍 Golang 如何实现 HTTP 服务端及客户端。</p><h2 id=1-http协议客户端实现>1. HTTP协议客户端实现</h2><p>Go语言标准库内置了net/http包，涵盖了HTTP客户端和服务端具体的实现方式。内置的net/http包提供了最简洁的HTTP客户端实现方式，无须借助第三方网络通信库，就可以直接使用HTTP中用得最多的GET和POST方式请求数据。</p><p>实现HTTP客户端就是客户端通过网络访问向服务端发送请求，服务端发送响应信息，并将相应信息输出到客户端的过程。实现客户端有多种方式，具体如下所示。</p><h3 id=11-使用httpnewrequest方法>1.1 使用http.NewRequest()方法</h3><p>首先创建一个client（客户端）对象，其次创建一个request（请求）对象，最后使用client发送request。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
	<span style=color:#b44>&#34;net/http&#34;</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#00a000>testHttpNewRequest</span>()
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>testHttpNewRequest</span>() {
	<span style=color:#080;font-style:italic>//1.创建一个客户端
</span><span style=color:#080;font-style:italic></span>	client <span style=color:#666>:=</span> http.Client{}
	<span style=color:#080;font-style:italic>//2.创建一个请求，请求方式可以是GET或POST
</span><span style=color:#080;font-style:italic></span>	request, err <span style=color:#666>:=</span> http.<span style=color:#00a000>NewRequest</span>(<span style=color:#b44>&#34;GET&#34;</span>, <span style=color:#b44>&#34;http://www.baidu.com&#34;</span>, <span style=color:#a2f;font-weight:700>nil</span>)
	<span style=color:#00a000>checkErr</span>(err)
	<span style=color:#080;font-style:italic>//3.客户端发送请求
</span><span style=color:#080;font-style:italic></span>	cookName <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>http.Cookie{Name: <span style=color:#b44>&#34;username&#34;</span>, Value: <span style=color:#b44>&#34;Steven&#34;</span>}

	<span style=color:#080;font-style:italic>//添加cookie
</span><span style=color:#080;font-style:italic></span>	request.<span style=color:#00a000>AddCookie</span>(cookName)
	response, err <span style=color:#666>:=</span> client.<span style=color:#00a000>Do</span>(request)
	<span style=color:#00a000>checkErr</span>(err)
	<span style=color:#080;font-style:italic>//设置请求头
</span><span style=color:#080;font-style:italic></span>	request.Header.<span style=color:#00a000>Set</span>(<span style=color:#b44>&#34;Accept-Lanauage&#34;</span>, <span style=color:#b44>&#34;zh-cn&#34;</span>)
	<span style=color:#a2f;font-weight:700>defer</span> response.Body.<span style=color:#00a000>Close</span>()
	<span style=color:#080;font-style:italic>//查看请求头的数据
</span><span style=color:#080;font-style:italic></span>	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;Header:%+v\n&#34;</span>, request.Header)
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;响应状态码: %v\n&#34;</span>, response.StatusCode)

	<span style=color:#080;font-style:italic>//4.操作数据
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>if</span> response.StatusCode <span style=color:#666>==</span> <span style=color:#666>200</span> {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;网络请求成功&#34;</span>)
		<span style=color:#00a000>checkErr</span>(err)
	} <span style=color:#a2f;font-weight:700>else</span> {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;网络请求失败&#34;</span>, response.Status)
	}
}

<span style=color:#080;font-style:italic>//检查错误
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>checkErr</span>(err <span style=color:#0b0;font-weight:700>error</span>) {
	<span style=color:#a2f;font-weight:700>defer</span> <span style=color:#a2f;font-weight:700>func</span>() {
		<span style=color:#a2f;font-weight:700>if</span> ins, ok <span style=color:#666>:=</span> <span style=color:#a2f>recover</span>().(<span style=color:#0b0;font-weight:700>error</span>); ok {
			fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;程序出现异常: &#34;</span>, ins.<span style=color:#00a000>Error</span>())
		}
	}()
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f>panic</span>(err)
	}
}
</code></pre></div><p>运行结果如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go run main.go
Header:map<span style=color:#666>[</span>Accept-Lanauage:<span style=color:#666>[</span>zh-cn<span style=color:#666>]</span> Cookie:<span style=color:#666>[</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>Steven<span style=color:#666>]</span><span style=color:#666>]</span>
响应状态码: <span style=color:#666>200</span>
网络请求成功 
</code></pre></div><h3 id=12-调用clientget-方法>1.2 调用client.Get() 方法</h3><p>这种方法总共两个步骤，先创建一个client（客户端）对象，然后使用client调用Get()方法。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
	<span style=color:#b44>&#34;net/http&#34;</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#00a000>testClientGet</span>()
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>testClientGet</span>() {
	<span style=color:#080;font-style:italic>//1.创建一个客户端
</span><span style=color:#080;font-style:italic></span>	client <span style=color:#666>:=</span> http.Client{}
	<span style=color:#080;font-style:italic>//2.通过client请求
</span><span style=color:#080;font-style:italic></span>	response, err <span style=color:#666>:=</span> client.<span style=color:#00a000>Get</span>(<span style=color:#b44>&#34;http://www.baidu.com&#34;</span>)
	<span style=color:#00a000>checkErr</span>(err)

	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;响应状态码: %v\n&#34;</span>, response.StatusCode)

	<span style=color:#a2f;font-weight:700>if</span> response.StatusCode <span style=color:#666>==</span> <span style=color:#666>200</span> {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;网络请求成功&#34;</span>)
		<span style=color:#a2f;font-weight:700>defer</span> response.Body.<span style=color:#00a000>Close</span>()
	}
}

<span style=color:#080;font-style:italic>//检查错误
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>checkErr</span>(err <span style=color:#0b0;font-weight:700>error</span>) {
	<span style=color:#a2f;font-weight:700>defer</span> <span style=color:#a2f;font-weight:700>func</span>() {
		<span style=color:#a2f;font-weight:700>if</span> ins, ok <span style=color:#666>:=</span> <span style=color:#a2f>recover</span>().(<span style=color:#0b0;font-weight:700>error</span>); ok {
			fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;程序出现异常: &#34;</span>, ins.<span style=color:#00a000>Error</span>())
		}
	}()
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f>panic</span>(err)
	}
}

</code></pre></div><p>运行结果如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go run main.go
响应状态码: <span style=color:#666>200</span>
网络请求成功
</code></pre></div><h3 id=13-使用clientpost或clientpostform方法>1.3 使用client.Post()或client.PostForm()方法</h3><p>这种方法也是两个步骤，先创建一个client（客户端）对象，然后使用client调用Post()或PostForm()方法。其实client的Post()或PostForm()方法，就是对http.NewRequest()的封装。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>resp, err <span style=color:#666>:=</span> http.<span style=color:#00a000>Post</span>(<span style=color:#b44>&#34;http://example.com/upload&#34;</span>, <span style=color:#b44>&#34;image/jpeg&#34;</span>, <span style=color:#666>&amp;</span>buf)
<span style=color:#666>...</span>
resp, err <span style=color:#666>:=</span> http.<span style=color:#00a000>PostForm</span>(<span style=color:#b44>&#34;http://example.com/form&#34;</span>,
	url.Values{<span style=color:#b44>&#34;key&#34;</span>: {<span style=color:#b44>&#34;Value&#34;</span>}, <span style=color:#b44>&#34;id&#34;</span>: {<span style=color:#b44>&#34;123&#34;</span>}})
</code></pre></div><h3 id=14-使用httpget-方法>1.4 使用http.Get() 方法</h3><p>这种方式只有一个步骤，http的Get()方法就是对DefaultClient.Get()的封装。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
	<span style=color:#b44>&#34;net/http&#34;</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#00a000>testHttpGet</span>()
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>testHttpGet</span>() {
	<span style=color:#080;font-style:italic>//获取服务器数据
</span><span style=color:#080;font-style:italic></span>	response, err <span style=color:#666>:=</span> http.<span style=color:#00a000>Get</span>(<span style=color:#b44>&#34;http://www.baidu.com&#34;</span>)
	<span style=color:#00a000>checkErr</span>(err)
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;响应状态码: %v\n&#34;</span>, response.StatusCode)

	<span style=color:#a2f;font-weight:700>if</span> response.StatusCode <span style=color:#666>==</span> <span style=color:#666>200</span> {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;网络请求成功&#34;</span>)
		<span style=color:#a2f;font-weight:700>defer</span> response.Body.<span style=color:#00a000>Close</span>()
		<span style=color:#00a000>checkErr</span>(err)
	} <span style=color:#a2f;font-weight:700>else</span> {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;请求失败&#34;</span>, response.Status)
	}
}

<span style=color:#080;font-style:italic>//检查错误
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>checkErr</span>(err <span style=color:#0b0;font-weight:700>error</span>) {
	<span style=color:#a2f;font-weight:700>defer</span> <span style=color:#a2f;font-weight:700>func</span>() {
		<span style=color:#a2f;font-weight:700>if</span> ins, ok <span style=color:#666>:=</span> <span style=color:#a2f>recover</span>().(<span style=color:#0b0;font-weight:700>error</span>); ok {
			fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;程序出现异常: &#34;</span>, ins.<span style=color:#00a000>Error</span>())
		}
	}()
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f>panic</span>(err)
	}
}

</code></pre></div><p>运行结果为</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go run main.go
响应状态码: <span style=color:#666>200</span>
网络请求成功
</code></pre></div><h3 id=15-使用httppost或httppostform方法>1.5 使用http.Post()或http.PostForm()方法</h3><p>http的Post()函数或PostForm()，就是对DefaultClient.Post()或DefaultClient.PostForm()的封装。这种方法也只需要一个步骤</p><h2 id=2-http协议服务端实现>2. HTTP协议服务端实现</h2><p>使用Go语言标准库内置的net/http包，就可以实现一个基本的HTTP服务端。一个基本的HTTP服务器主要应完成如下功能</p><ol><li>处理动态请求：处理浏览网站，登录帐户或发布图片等用户传入的请求。</li><li>提供静态文件：将JavaScript，CSS和图像等静态文件提供给浏览器，服务于用户。</li><li>接受连接请求：HTTP服务器必须监听指定端口从而接收来自网络的连接请求。</li></ol><h3 id=21-处理动态请求>2.1 处理动态请求</h3><p>我们可以使用<code>http.HandleFunc</code>函数注册一个新的 Handler 来处理动态请求。它的第一个参数是请求路径的匹配模式，第二个参数是一个函数类型，表示针对这个请求要执行的功能。下例中针对请求返回一个欢迎访问的提示语。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/&#34;</span>, <span style=color:#a2f;font-weight:700>func</span> (w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
    fmt.<span style=color:#00a000>Fprint</span>(w, <span style=color:#b44>&#34;Welcome to my website!&#34;</span>)
})
</code></pre></div><p><code>http.ResponseWriter</code>类型包含了服务器端给客户端的响应数据。服务器端往里面写入了什么内容，浏览器的网页源码就是什么内容。<code>*http.Request</code>包含了客户端发送给服务器端的请求信息（路径、浏览器类型等）。</p><h3 id=22-提供静态文件>2.2 提供静态文件</h3><p>使用<code>http.FileServer()</code> 方法提供 Javascript，CSS或图片等静态文件。它的参数是文件系统接口，可以使用<code>http.Dir()</code>来指定文件所在的路径。如果该路径中有index.html文件，则会优先显示html文件，否则会显示文件目录。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>fs <span style=color:#666>:=</span> http.<span style=color:#00a000>FileServer</span>(http.<span style=color:#00a000>Dir</span>(<span style=color:#b44>&#34;static/&#34;</span>))
</code></pre></div><p><code>http.FileServer()</code>的返回值正好是 Handler 类型，也就是可以提供文件访问服务的HTTP处理器。现在，我们只需要将一个URL指向它，期间我们可以使用<code>http.StripPrefix()</code> 去除某些URL前缀，返回值同样是一个 Handler类型</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>Handle</span>(<span style=color:#b44>&#34;/static/&#34;</span>, http.<span style=color:#00a000>StripPrefix</span>(<span style=color:#b44>&#34;/static/&#34;</span>, fs))
</code></pre></div><h3 id=23-接收连接请求>2.3 接收连接请求</h3><p><code>http.ListenAndServer()</code>函数用来启动HTTP服务器，并且在指定的 IP 地址和端口上监听客户端请求</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>ListenAndServe</span>(<span style=color:#b44>&#34;:80&#34;</span>, <span style=color:#a2f;font-weight:700>nil</span>)
</code></pre></div><p>函数实现如下，其中第一个参数为监听地址，第二个参数表示一个HTTP处理器 Handler。可以看到，底层调用的是 <code>net/http</code> 包的 <code>ListenAndServe</code> 方法，首先会初始化一个 <code>Server</code> 对象，然后调用该 <code>Server</code> 实例的 <code>ListenAndServe</code> 方法，进而调用 <code>net.Listen("tcp", addr)</code>，也就是基于 TCP 协议创建 Listen Socket，并在传入的IP 地址和端口号上监听请求。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>ListenAndServe</span>(addr <span style=color:#0b0;font-weight:700>string</span>, handler Handler) <span style=color:#0b0;font-weight:700>error</span> {
	server <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>Server{Addr: addr, Handler: handler}
	<span style=color:#a2f;font-weight:700>return</span> server.<span style=color:#00a000>ListenAndServe</span>()
}

<span style=color:#a2f;font-weight:700>func</span> (srv <span style=color:#666>*</span>Server) <span style=color:#00a000>ListenAndServe</span>() <span style=color:#0b0;font-weight:700>error</span> {
	<span style=color:#a2f;font-weight:700>if</span> srv.<span style=color:#00a000>shuttingDown</span>() {
		<span style=color:#a2f;font-weight:700>return</span> ErrServerClosed
	}
	addr <span style=color:#666>:=</span> srv.Addr
	<span style=color:#a2f;font-weight:700>if</span> addr <span style=color:#666>==</span> <span style=color:#b44>&#34;&#34;</span> {
		addr = <span style=color:#b44>&#34;:http&#34;</span>
	}
	ln, err <span style=color:#666>:=</span> net.<span style=color:#00a000>Listen</span>(<span style=color:#b44>&#34;tcp&#34;</span>, addr)
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f;font-weight:700>return</span> err
	}
	<span style=color:#a2f;font-weight:700>return</span> srv.<span style=color:#00a000>Serve</span>(ln)
}
</code></pre></div><p>最终我们看到调用了 <code>Server</code> 实例的 <code>Serve(net.Listener)</code> 方法，这个方法里面起了一个 <code>for</code> 循环，在循环体中首先通过 <code>net.Listener</code>（即上一步监听端口中创建的 Listen Socket）实例的 <code>Accept</code> 方法接收客户端请求，接收到请求后根据请求信息创建一个 <code>conn</code> 连接实例，最后单独开了一个 goroutine，把这个请求的数据当做参数扔给这个 <code>conn</code> 去服务：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>for</span> {
		rw, err <span style=color:#666>:=</span> l.<span style=color:#00a000>Accept</span>()
		<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			<span style=color:#666>...</span>
		}
		connCtx <span style=color:#666>:=</span> ctx
		<span style=color:#a2f;font-weight:700>if</span> cc <span style=color:#666>:=</span> srv.ConnContext; cc <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			connCtx = <span style=color:#00a000>cc</span>(connCtx, rw)
			<span style=color:#a2f;font-weight:700>if</span> connCtx <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
				<span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;ConnContext returned nil&#34;</span>)
			}
		}
		tempDelay = <span style=color:#666>0</span>
		c <span style=color:#666>:=</span> srv.<span style=color:#00a000>newConn</span>(rw)
		c.<span style=color:#00a000>setState</span>(c.rwc, StateNew) <span style=color:#080;font-style:italic>// before Serve can return
</span><span style=color:#080;font-style:italic></span>		<span style=color:#a2f;font-weight:700>go</span> c.<span style=color:#00a000>serve</span>(connCtx)
	}
</code></pre></div><p>用户的每一次请求都是在一个新的 goroutine 去服务，相互不影响。客户端请求的具体处理逻辑都是在 <code>c.serve</code> 中完成的。 <code>conn</code> 实例的 <code>serve</code> 方法首先会通过 <code>c.readRequest()</code> 解析请求，然后在 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 的 <code>ServeHTTP</code> 方法中获取相应的 <code>handler</code>：<code>handler := c.server.Handler</code>，也就是我们刚才在调用函数 <code>ListenAndServe</code> 时候的第二个参数。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (sh serverHandler) <span style=color:#00a000>ServeHTTP</span>(rw ResponseWriter, req <span style=color:#666>*</span>Request) {
	handler <span style=color:#666>:=</span> sh.srv.Handler
	<span style=color:#a2f;font-weight:700>if</span> handler <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		handler = DefaultServeMux
	}
	<span style=color:#a2f;font-weight:700>if</span> req.RequestURI <span style=color:#666>==</span> <span style=color:#b44>&#34;*&#34;</span> <span style=color:#666>&amp;&amp;</span> req.Method <span style=color:#666>==</span> <span style=color:#b44>&#34;OPTIONS&#34;</span> {
		handler = globalOptionsHandler{}
	}
	handler.<span style=color:#00a000>ServeHTTP</span>(rw, req)
}
</code></pre></div><p>我们发现当 handler 为 nil，也就是 ListenAndServe() 的第二个参数为 nil 时，使用了默认的 http.DefaultServeMux，这是 ServeMux的默认实例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> DefaultServeMux = <span style=color:#666>&amp;</span>defaultServeMux
<span style=color:#a2f;font-weight:700>var</span> defaultServeMux ServeMux
</code></pre></div><p>ServeMux的数据结构如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> ServeMux <span style=color:#a2f;font-weight:700>struct</span> {
    mu    sync.RWMutex. <span style=color:#080;font-style:italic>// 由于请求涉及到并发处理，因此这里需要一个锁机制
</span><span style=color:#080;font-style:italic></span>    m     <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]muxEntry <span style=color:#080;font-style:italic>// 路由规则字典，存放 URL 路径与处理器的映射关系
</span><span style=color:#080;font-style:italic></span>    es    []muxEntry <span style=color:#080;font-style:italic>// MuxEntry 切片（按照最长到最短排序）
</span><span style=color:#080;font-style:italic></span>    hosts <span style=color:#0b0;font-weight:700>bool</span>       <span style=color:#080;font-style:italic>// 路由规则中是否包含 host 信息
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>这里，我们需要重点关注的是 <code>muxEntry</code> 结构：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> muxEntry <span style=color:#a2f;font-weight:700>struct</span> {
    h   Handler       <span style=color:#080;font-style:italic>// 处理器具体实现
</span><span style=color:#080;font-style:italic></span>    pattern <span style=color:#0b0;font-weight:700>string</span>    <span style=color:#080;font-style:italic>// 模式匹配字符串
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>最后我们来看一下 <code>Handler</code> 的定义，这是一个接口：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Handler <span style=color:#a2f;font-weight:700>interface</span> {
    <span style=color:#00a000>ServeHTTP</span>(ResponseWriter, <span style=color:#666>*</span>Request) <span style=color:#080;font-style:italic>// 路由处理实现方法
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>当请求路径与 <code>pattern</code> 匹配时，就会调用 <code>Handler</code> 的 <code>ServeHTTP</code> 方法来处理请求。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/&#34;</span>, sayHelloWorld)
</code></pre></div><p>当我们使用一个自定义的处理函数时，如上面的sayHelloWorld，并没有实现 <code>Handler</code> 接口，之所以可以成功添加到路由映射规则，是因为在底层通过 <code>HandlerFunc()</code> 函数将其强制转化为了 <code>HandlerFunc</code> 类型，而 <code>HandlerFunc</code> 类型实现了 <code>ServeHTTP</code> 方法，这样，<code>sayHelloWorld</code> 方法也就变相实现了 <code>Handler</code> 接口</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (mux <span style=color:#666>*</span>ServeMux) <span style=color:#00a000>HandleFunc</span>(pattern <span style=color:#0b0;font-weight:700>string</span>, handler <span style=color:#a2f;font-weight:700>func</span>(ResponseWriter, <span style=color:#666>*</span>Request)) {
    <span style=color:#a2f;font-weight:700>if</span> handler <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		  <span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;http: nil handler&#34;</span>)
    }
    mux.<span style=color:#00a000>Handle</span>(pattern, <span style=color:#00a000>HandlerFunc</span>(handler))
}

<span style=color:#666>...</span>

<span style=color:#a2f;font-weight:700>type</span> HandlerFunc <span style=color:#a2f;font-weight:700>func</span>(ResponseWriter, <span style=color:#666>*</span>Request)

<span style=color:#a2f;font-weight:700>func</span> (f HandlerFunc) <span style=color:#00a000>ServeHTTP</span>(w ResponseWriter, r <span style=color:#666>*</span>Request) {
    <span style=color:#00a000>f</span>(w, r)
}
</code></pre></div><p>对于 <code>sayHelloWorld</code> 方法来说，它已然变成了 <code>HandlerFunc</code> 类型的函数类型，当我们在其实例上调用 <code>ServeHTTP</code> 方法时，调用的是 <code>sayHelloWorld</code> 方法本身。</p><p>前面我们提到，<code>DefaultServeMux</code> 是 <code>ServeMux</code> 的默认实例，当我们在 <code>HandleFunc</code> 中调用 <code>mux.Handle</code> 方法时，实际上是将其路由映射规则保存到 <code>DefaultServeMux</code> 路由处理器的数据结构中：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (mux <span style=color:#666>*</span>ServeMux) <span style=color:#00a000>Handle</span>(pattern <span style=color:#0b0;font-weight:700>string</span>, handler Handler) {
	mux.mu.<span style=color:#00a000>Lock</span>()
	<span style=color:#a2f;font-weight:700>defer</span> mux.mu.<span style=color:#00a000>Unlock</span>()

	<span style=color:#a2f;font-weight:700>if</span> pattern <span style=color:#666>==</span> <span style=color:#b44>&#34;&#34;</span> {
		<span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;http: invalid pattern&#34;</span>)
	}
	<span style=color:#a2f;font-weight:700>if</span> handler <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;http: nil handler&#34;</span>)
	}
	<span style=color:#a2f;font-weight:700>if</span> _, exist <span style=color:#666>:=</span> mux.m[pattern]; exist {
		<span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;http: multiple registrations for &#34;</span> <span style=color:#666>+</span> pattern)
	}

	<span style=color:#a2f;font-weight:700>if</span> mux.m <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		mux.m = <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]muxEntry)
	}
	e <span style=color:#666>:=</span> muxEntry{h: handler, pattern: pattern}
	mux.m[pattern] = e
	<span style=color:#a2f;font-weight:700>if</span> pattern[<span style=color:#a2f>len</span>(pattern)<span style=color:#666>-</span><span style=color:#666>1</span>] <span style=color:#666>==</span> <span style=color:#b44>&#39;/&#39;</span> {
		mux.es = <span style=color:#00a000>appendSorted</span>(mux.es, e)
	}

	<span style=color:#a2f;font-weight:700>if</span> pattern[<span style=color:#666>0</span>] <span style=color:#666>!=</span> <span style=color:#b44>&#39;/&#39;</span> {
		mux.hosts = <span style=color:#a2f;font-weight:700>true</span>
	}
}
</code></pre></div><p>还是以 <code>sayHelloWorld</code> 为例，这里的 <code>pattern</code> 字符串对应的是请求路径 <code>/</code>，<code>handler</code> 对应的是 <code>sayHelloWorld</code> 函数。</p><p>保存好路由映射规则之后，客户端请求的处理就默认调用<code>ServeMux</code> 实现的 <code>ServeHTTP</code> 方法：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (mux <span style=color:#666>*</span>ServeMux) <span style=color:#00a000>ServeHTTP</span>(w ResponseWriter, r <span style=color:#666>*</span>Request) {
    <span style=color:#a2f;font-weight:700>if</span> r.RequestURI <span style=color:#666>==</span> <span style=color:#b44>&#34;*&#34;</span> {
        w.<span style=color:#00a000>Header</span>().<span style=color:#00a000>Set</span>(<span style=color:#b44>&#34;Connection&#34;</span>, <span style=color:#b44>&#34;close&#34;</span>)
        w.<span style=color:#00a000>WriteHeader</span>(StatusBadRequest)
        <span style=color:#a2f;font-weight:700>return</span>
    }
    
    h, _ <span style=color:#666>:=</span> mux.<span style=color:#00a000>Handler</span>(r)
    h.<span style=color:#00a000>ServeHTTP</span>(w, r)
}
</code></pre></div><p>如上所示，路由处理器接收到请求之后，如果 URL 路径是 <code>*</code>，则关闭连接，否则调用 <code>mux.Handler(r)</code> 返回对应请求路径匹配的处理器，然后执行 <code>h.ServeHTTP(w, r)</code>，也就是调用对应路由 <code>handler</code> 的 <code>ServerHTTP</code> 方法，以 <code>/</code> 路由为例，调用的就是 <code>sayHelloWorld</code> 函数本身。</p><p><strong>总结</strong></p><p>现在我们来捋一下，当我们调用 http.ListenAndServe，首先建立了一个 Server 实例，然后把两个参数都赋给了该实例，之后我们在该实例的基础上调用底层 net 包监听端口、创建socket并开启连接，最后把这个连接交给了 Server实例的 handler处理，这个handler 正是我们在 ListenAndServe 中传入的第二个参数。</p><p>当第二个参数为 nil 时调用了 ServeMux 的默认实例 DefaultServeMux ，该实例实现了一个 ServeMux 结构体，而这个结构体中最重要的一个字段就是muxEntry 结构体，包含 pattern 和 handler 两部分。所以我们实现 Handle 和 HandleFunc 都是在将路由映射规则保存到 <code>DefaultServeMux</code> 路由处理器的 muxEntry 结构体的这两个字段。</p><p>客户端请求的处理就默认调用<code>ServeMux</code> 实现的 <code>ServeHTTP</code> 方法，把对应的请求交给对应的处理器。</p><h3 id=24-获取客户端提交的数据>2.4 获取客户端提交的数据</h3><p>前面已经提到，客户端提交的数据全部位于 *http.Request 中，下面的例子虽然做了声明，但没有使用，本节介绍一下如何从 *http.request 中提取想要的数据</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/&#34;</span>, <span style=color:#a2f;font-weight:700>func</span> (w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
    fmt.<span style=color:#00a000>Fprint</span>(w, <span style=color:#b44>&#34;Welcome to my website!&#34;</span>)
})
</code></pre></div><p>Request的部分结构如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Request <span style=color:#a2f;font-weight:700>struct</span> {
    <span style=color:#666>...</span>
    <span style=color:#080;font-style:italic>// Method指定HTTP方法（GET、POST、PUT等）。对客户端，&#34;&#34;代表GET。
</span><span style=color:#080;font-style:italic></span>    Method <span style=color:#0b0;font-weight:700>string</span>
    <span style=color:#080;font-style:italic>// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。
</span><span style=color:#080;font-style:italic></span>    Form url.Values
    <span style=color:#080;font-style:italic>// PostForm是解析好的POST或PUT的表单数据。
</span><span style=color:#080;font-style:italic></span>    PostForm url.Values
    <span style=color:#666>...</span>
}
</code></pre></div><p>使用ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (r <span style=color:#666>*</span>Request) <span style=color:#00a000>ParseForm</span>() <span style=color:#0b0;font-weight:700>error</span>
</code></pre></div><p>然后使用 FormValue 返回以 key 为健查询 r.Form 得到的第一个值</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (r <span style=color:#666>*</span>Request) <span style=color:#00a000>FormValue</span>(key <span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>
</code></pre></div><p>PostFormValue则返回key为键查询r.PostForm字段得到的第一个值，用于POST和PUT</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (r <span style=color:#666>*</span>Request) <span style=color:#00a000>PostFormValue</span>(key <span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>
</code></pre></div><p>当提交的请求数据中有文件时，使用FormFile，可以返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (r <span style=color:#666>*</span>Request) <span style=color:#00a000>FormFile</span>(key <span style=color:#0b0;font-weight:700>string</span>) (multipart.File, <span style=color:#666>*</span>multipart.FileHeader, <span style=color:#0b0;font-weight:700>error</span>)
</code></pre></div><p>一个简单的实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>loginActionHandler</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
	r.<span style=color:#00a000>ParseForm</span>()
	<span style=color:#a2f;font-weight:700>if</span> r.Method <span style=color:#666>==</span> <span style=color:#b44>&#34;GET&#34;</span> <span style=color:#666>&amp;&amp;</span> r.<span style=color:#00a000>ParseForm</span>() <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		username <span style=color:#666>:=</span> r.<span style=color:#00a000>FormValue</span>(<span style=color:#b44>&#34;username&#34;</span>)
		pwd <span style=color:#666>:=</span> r.<span style=color:#00a000>FormValue</span>(<span style=color:#b44>&#34;password&#34;</span>)
		<span style=color:#a2f;font-weight:700>if</span> <span style=color:#a2f>len</span>(username) &lt; <span style=color:#666>4</span> <span style=color:#666>||</span> <span style=color:#a2f>len</span>(username) &gt; <span style=color:#666>10</span> {
			w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;用户名不符合规范&#34;</span>))
		}
		<span style=color:#a2f;font-weight:700>if</span> <span style=color:#a2f>len</span>(pwd) &lt; <span style=color:#666>6</span> <span style=color:#666>||</span> <span style=color:#a2f>len</span>(pwd) &gt; <span style=color:#666>16</span> {
			w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;密码不符合规范&#34;</span>))
		}
		http.<span style=color:#00a000>Redirect</span>(w, r, <span style=color:#b44>&#34;/list&#34;</span>, http.StatusFound)
		<span style=color:#a2f;font-weight:700>return</span>
	} <span style=color:#a2f;font-weight:700>else</span> {
		w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;请求方式不对&#34;</span>))
		<span style=color:#a2f;font-weight:700>return</span>
	}
	w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;登录失败&#34;</span>))
}
</code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/go%e5%ae%9e%e6%88%98 rel=tag title=Go实战>#Go实战#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-info><p><span>声明：</span>Golang启动HTTP服务器</p><p><span>链接：</span>https://shuzang.github.io/2020/05/golang-start-http-server/</p><p><span>作者：</span>书藏</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://shuzang.github.io/2020/05/golang-use-gorilla/mux-package/ rel=next title=Golang使用gorilla、mux包><i class="fa fa-chevron-left"></i>Golang使用gorilla、mux包</a></div><div class="post-nav-prev post-nav-item"><a href=https://shuzang.github.io/2020/05/development-of-online-forum-based-on-golang-3-visit-forum-homepage/ rel=prev title=基于Go语言开发在线论坛3-访问论坛首页>基于Go语言开发在线论坛3-访问论坛首页
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2018 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer();});</script><script type=text/javascript>$(function(){if(detectIE()>0){$.getScript(document.location.protocol+'//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',function(){new Waline({el:'#wcomments',visitor:true,avatar:'wavatar',avatarCDN:'https://sdn.geekzu.org/avatar/',avatarForce:!1,wordLimit:'200',placeholder:' 欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^ ',requiredFields:['nick','mail'],serverURL:"Your WalineSerURL",lang:"zh-cn"});});}else{$('#wcomments').html('抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。');}});</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>
<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>数据结构-二叉搜索树 - 书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="数据结构-二叉搜索树"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/avatar.png"><meta name=title content="数据结构-二叉搜索树 - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/2020/03/data-structure-binary-search-tree/ itemprop=url>数据结构-二叉搜索树</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-03-03">2020-03-03</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>爱编程爱技术的孩子</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>4982 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>10分钟</span></span>
<span id=/2020/03/data-structure-binary-search-tree/ class=leancloud_visitors data-flag-title=数据结构-二叉搜索树>|
<i class="fa fa-binoculars fa-fw"></i><span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>二叉搜索树是二叉树的一种特殊形式，由于它对查找的良好特性，使用较为广泛，本篇文章我们对其进行介绍，同时也包括二叉搜索树的各种进阶，比如二叉平衡树。</p><h2 id=1-二叉搜索树>1. 二叉搜索树</h2><h3 id=11-定义>1.1 定义</h3><p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。其定义如下</p><p>二叉搜索树：是一颗二叉树，可以为空，如果不为空，满足下列性质</p><ol><li>非空左子树的所有结点值小于其根结点的结点值</li><li>非空右子树的所有结点值小于其根结点的结点值</li><li>左右子树都是二叉搜索树</li></ol><p>一种最常见的题型就是判断一棵树是否为二叉搜索树，我们可以利用递归的思路来解决该问题，示例代码如下，每个节点有一次递归调用，因此时间复杂度为O(n)，递归深度为树高，因此空间复杂度为O(h)，h 为树高。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>isValidBST</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#0b0;font-weight:700>bool</span> {
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>helper</span>(root, math.MinInt64, math.MaxInt64)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>helper</span>(root <span style=color:#666>*</span>TreeNode, lower, upper <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>bool</span> {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>true</span>
    }
    <span style=color:#a2f;font-weight:700>if</span> root.Val <span style=color:#666>&lt;=</span> lower <span style=color:#666>||</span> root.Val <span style=color:#666>&gt;=</span> upper {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span>
    }
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>helper</span>(root.Left, lower,root.Val) <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>helper</span>(root.Right, root.Val, upper)
}
</code></pre></div><p>另外，我们还应该知道，对于二叉搜索树，中序遍历可以得到一个递增的序列，所以利用中序遍历也可以进行判断。代码如下，因为完全遍历一遍，时间复杂度为O(n)，栈的大小为节点数目，因此空间复杂度也为O(n)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>isValidBST</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#0b0;font-weight:700>bool</span> {
    stack <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#666>*</span>TreeNode,<span style=color:#666>0</span>)
    preNum <span style=color:#666>:=</span> math.MinInt64 <span style=color:#080;font-style:italic>// 用一个变量记录上一个数，和当前值比较
</span><span style=color:#080;font-style:italic></span>    
    <span style=color:#a2f;font-weight:700>for</span> root <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> <span style=color:#666>||</span> <span style=color:#a2f>len</span>(stack) <span style=color:#666>!=</span> <span style=color:#666>0</span> {
        <span style=color:#a2f;font-weight:700>for</span> root <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
            stack = <span style=color:#a2f>append</span>(stack,root)
            root = root.Left
        }
        
        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#a2f>len</span>(stack) <span style=color:#666>!=</span> <span style=color:#666>0</span> {
            root = stack[<span style=color:#a2f>len</span>(stack)<span style=color:#666>-</span><span style=color:#666>1</span>]
            stack = stack[:<span style=color:#a2f>len</span>(stack)<span style=color:#666>-</span><span style=color:#666>1</span>]
            
            <span style=color:#a2f;font-weight:700>if</span> root.Val <span style=color:#666>&lt;=</span> preNum {
                <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span>
            }            
            preNum = root.Val
            
            root = root.Right
        }
    }
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>true</span>
}
</code></pre></div><p>两种写法中都要注意，二叉搜索树必须左子树的所有节点都小于当前节点值，右子树的所有节点都大于当前节点值，等于是不可以的。换句话说，序列是严格递增的。</p><h3 id=12-基本操作>1.2 基本操作</h3><p>二叉搜索树的基本操作包括查找、插入和删除。</p><h4 id=查找>查找</h4><p>查找的基本思路是从根结点开始，如果树为空，返回NULL，如果树非空，则将根结点的值和X进行比较，分情况处理：</p><ol><li>如果X小于根结点的值，在左子树中继续搜索</li><li>如果X大于根结点的值，在右子树中继续搜索</li><li>若两者值相等，搜索完成，返回指向该结点的指针</li></ol><p>递归的实现思路如下，空间复杂度O(h)，时间复杂度O(h)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>searchBST</span>(root <span style=color:#666>*</span>TreeNode, val <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> <span style=color:#666>||</span> root.Val <span style=color:#666>==</span> val {
        <span style=color:#a2f;font-weight:700>return</span> root
    }
    <span style=color:#a2f;font-weight:700>if</span> val &lt; root.Val {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>searchBST</span>(root.Left,val)
    }<span style=color:#a2f;font-weight:700>else</span>{
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>searchBST</span>(root.Right,val)
    }
}
</code></pre></div><p>迭代的实现思路如下，空间复杂度O(1)，时间复杂度O(h)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>searchBST</span>(root <span style=color:#666>*</span>TreeNode, val <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>for</span> root <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>if</span> val &lt; root.Val {
            root = root.Left
        }<span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> val &gt; root.Val {
            root = root.Right
        }<span style=color:#a2f;font-weight:700>else</span>{
            <span style=color:#a2f;font-weight:700>return</span> root
        }
    }
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
}
</code></pre></div><h4 id=插入>插入</h4><p>二叉搜索树插入节点的方法是将其作为某个叶节点的子节点，核心是找到待插入的叶节点，一个递归的实现如下，时间和空间复杂度都是O(h)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>insertIntoBST</span>(root <span style=color:#666>*</span>TreeNode, val <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>TreeNode {
	<span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		root = <span style=color:#666>&amp;</span>TreeNode{val, <span style=color:#a2f;font-weight:700>nil</span>, <span style=color:#a2f;font-weight:700>nil</span>}
	} 
    
    <span style=color:#a2f;font-weight:700>if</span> val &gt; root.Val {
        root.Right = <span style=color:#00a000>insertIntoBST</span>(root.Right, val)
    } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> val &lt; root.Val {
        root.Left = <span style=color:#00a000>insertIntoBST</span>(root.Left, val)
    }

	<span style=color:#a2f;font-weight:700>return</span> root
}
</code></pre></div><p>迭代的实现如下，时间复杂度为O(h)，空间复杂度为O(1)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>insertIntoBST</span>(root <span style=color:#666>*</span>TreeNode, val <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>TreeNode {
    newNode <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>TreeNode{Val:val}
    cur <span style=color:#666>:=</span> root
    
    <span style=color:#a2f;font-weight:700>for</span> cur <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>if</span> val &lt; cur.Val {
            <span style=color:#a2f;font-weight:700>if</span> cur.Left <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
                cur.Left = newNode
                <span style=color:#a2f;font-weight:700>return</span> root
            }<span style=color:#a2f;font-weight:700>else</span>{
                cur = cur.Left 
            }       
        }<span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> val &gt; cur.Val {
            <span style=color:#a2f;font-weight:700>if</span> cur.Right <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
                cur.Right = newNode
                <span style=color:#a2f;font-weight:700>return</span> root
            }<span style=color:#a2f;font-weight:700>else</span>{
                cur = cur.Right
            }         
        }
    }
    
    <span style=color:#a2f;font-weight:700>return</span> newNode
}
</code></pre></div><h4 id=删除>删除</h4><p>二叉树的删除比较复杂，要考虑三种情况</p><ol><li><p>要删除的是叶节点，则直接删除，并修改其父结点指针为NULL</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3S7N0U.png alt=二叉搜索树删除叶结点></p></li><li><p>要删除的结点只有一个孩子，则将其父结点的指针指向要删除结点的孩子结点</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3SHE4J.png alt=二叉搜索树要删除的结点只有一个孩子></p></li><li><p>要删除的结点有左右两颗子树，则用另一个结点替代被删除的结点，可以是右子树的最小结点，也可以是左子树的最大结点</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3SqOAO.png alt=二叉搜索树要删除的结点有两颗子树></p></li></ol><p>所以删除操作会涉及两个额外的操作，查找最大和最小元素，这两个操作只需要记住两点：</p><ul><li>最大元素一定在树的最右分支的端结点上</li><li>最小元素一定在树的最左分支的端结点上</li></ul><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3SfTds.png alt=查找最大最小元素></p><p>查找最小元素的递归方法参考实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>FindMin</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> 
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
    <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> root<span style=color:#666>-</span>&gt;Left <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span>
        <span style=color:#a2f;font-weight:700>return</span> root
    <span style=color:#a2f;font-weight:700>else</span>
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>FindMin</span>(root<span style=color:#666>-</span>&gt;Left)
}
</code></pre></div><p>查找最大元素的迭代方法参考实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>findMax</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
	<span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f;font-weight:700>for</span> root.Right <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			root = root.Right
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> root
}
</code></pre></div><p>最后，删除操作的参考实现如下，时间复杂度和空间复杂度都是O(h)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>deleteNode</span>(root <span style=color:#666>*</span>TreeNode, key <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>TreeNode {
	<span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
	<span style=color:#a2f;font-weight:700>if</span> key &lt; root.Val {
		root.Left = <span style=color:#00a000>deleteNode</span>(root.Left, key)
	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> key &gt; root.Val {
		root.Right = <span style=color:#00a000>deleteNode</span>(root.Right, key)
	} <span style=color:#a2f;font-weight:700>else</span> {
		<span style=color:#a2f;font-weight:700>if</span> root.Left <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> <span style=color:#666>&amp;&amp;</span> root.Right <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			root.Val = <span style=color:#00a000>findMin</span>(root.Right).Val
			root.Right = <span style=color:#00a000>deleteNode</span>(root.Right, root.Val)
		} <span style=color:#a2f;font-weight:700>else</span> {
			<span style=color:#a2f;font-weight:700>if</span> root.Left <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
				root = root.Right
			} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> root.Right <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
				root = root.Left
			}
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> root
}
</code></pre></div><h3 id=13-最近公共祖先>1.3 最近公共祖先</h3><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>虽然我们这里讨论二叉搜索树的最近公共祖先，但对于普通的二叉树，也有求最近公共祖先的题型，其递归解法遵循这样的思路</p><ol><li>如果根结点为 nil，那么最近公共祖先为 nil</li><li>如果根结点等于两个节点中的任何一个，那么最近公共祖先就是根结点</li><li>此时我们递归调用分别求以左节点和右节点为根，针对 p,q 两个节点的最近公共祖先，如果两边返回的值都不为空，那么最近公共祖先是根结点。这里的逻辑是这样的，因为我们前面的条件中只要 p或q 任何一个节点等于根结点，就会返回，所以这一步递归调用的结果只能说明子树中包含 p 或 q，所以如果两个子树的返回值都不为空，说明 p,q 分别位于两个子树中，那么最近公共祖先是根结点；</li><li>这一步我们就能确定最近公共祖先不是在左子树就是在右子树，返回非空的一方即可</li></ol><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>lowestCommonAncestor</span>(root, p, q <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
    }
    <span style=color:#a2f;font-weight:700>if</span> root.Val <span style=color:#666>==</span> p.Val <span style=color:#666>||</span> root.Val <span style=color:#666>==</span> q.Val {
        <span style=color:#a2f;font-weight:700>return</span> root
    }
    left <span style=color:#666>:=</span> <span style=color:#00a000>lowestCommonAncestor</span>(root.Left, p, q)
    right <span style=color:#666>:=</span> <span style=color:#00a000>lowestCommonAncestor</span>(root.Right, p, q)
    <span style=color:#a2f;font-weight:700>if</span> left <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> <span style=color:#666>&amp;&amp;</span> right <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> root
    }
    <span style=color:#a2f;font-weight:700>if</span> left <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> right
    }
    <span style=color:#a2f;font-weight:700>return</span> left
}
</code></pre></div><p>递归解法的时间和空间复杂度都是O(n)，如果用迭代解法，其实就是遍历二叉树，然后用哈希表记录每个节点的父节点，然后遇到 p 和 q 就往祖先节点回溯，找到公共的祖先。</p><p>如果求二叉搜索树的最近公共祖先，二叉树的解法当然是适用的，但是没有充分利用二叉搜索树的特性，如果我们利用其二叉搜索树的特性，递归的思路更加简单。我们可以这样想</p><ol><li>从根结点开始</li><li>如果节点 p 和节点 q 的值都小于根结点的值，那么最近公共祖先一定在左子树；</li><li>如果节点 p 和节点 q 的值都大于根结点的值，那么最近公共祖先一定在右子树。</li></ol><p>代码如下，时间复杂度和空间复杂度都是O(h)，h为树高</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>lowestCommonAncestor</span>(root, p, q <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>if</span> p.Val &lt; root.Val <span style=color:#666>&amp;&amp;</span> q.Val &lt; root.Val {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>lowestCommonAncestor</span>(root.Left,p,q)
    }
    <span style=color:#a2f;font-weight:700>if</span> p.Val &gt; root.Val <span style=color:#666>&amp;&amp;</span> q.Val &gt; root.Val {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>lowestCommonAncestor</span>(root.Right,p,q)
    }
    
    <span style=color:#a2f;font-weight:700>return</span> root
}
</code></pre></div><p>如果我们用迭代的话，还是同样的思路，但是空间复杂度可以到O(1)</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>lowestCommonAncestor</span>(root, p, q <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>for</span> root <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>if</span> p.Val &lt; root.Val <span style=color:#666>&amp;&amp;</span> q.Val &lt; root.Val {
            root = root.Left
        }<span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> p.Val &gt; root.Val <span style=color:#666>&amp;&amp;</span> q.Val &gt; root.Val {
            root = root.Right
        }<span style=color:#a2f;font-weight:700>else</span>{
            <span style=color:#a2f;font-weight:700>return</span> root
        }
    }    
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
}
</code></pre></div><h2 id=2-平衡二叉树>2. 平衡二叉树</h2><p>平衡二叉树（Balanced Binary Tree），它要么是一颗空树，要么满足任一结点左右子树高度差的绝对值不超过1。一般使用「平衡因子（Balance Factor, BF）」来描述这一高度差，设H<sub>L</sub>和H<sub>R</sub>分别为树T左右子树的高度，则BF满足：
$$
BF(T) = \left|H_L - H_R\right| \le 1
$$
此外，平衡二叉树的高度为$O(\log_2n)$,证明如下</p><blockquote><p>设$f_n$为高度为n的AVL树所包含的最少结点数，则有
$$
f_n= \begin{cases} 1&(n=1)\ \\ 2&(n=2)\ \\ f_{n-1}+f_{n-2}+1& (n>2) \end{cases}
$$
显然$\{ f_n + 1 \}$是一个斐波那契数列，由于斐波那契数列以指数的速度增长，因此AVL树的高度为$O(\log_2n)$</p></blockquote><p>注意，给定节点数，树高可能有两种情况，我们对树高和这个高度允许的节点数列表如下，</p><table><thead><tr><th>树高</th><th>节点数范围</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2-3</td></tr><tr><td>3</td><td>4-7</td></tr><tr><td>4</td><td>7-15</td></tr><tr><td>5</td><td>12-31</td></tr></tbody></table><p>所以给定节点数N，其高度可能是 $log_2n- 1$ 或 $log_2n$ 或 $log_2n +1$</p><p>给定高度，最少节点数就只能通过递推得到，或者通过通项公式，最多节点数就是满二叉树的节点个数。</p><p>判断一棵二叉树是否为平衡二叉树，根据定义，我们有两种思路</p><ol><li>计算节点总数和树的高度，从而确定树是否平衡（实际实践有难度，因为通项公式不容易求）；</li><li>分别计算左右子树的深度，然后判断差是否为1</li></ol><p>以第二种方法为例，代码如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>isBalanced</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#0b0;font-weight:700>bool</span> {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>true</span>
    }
    t <span style=color:#666>:=</span> <span style=color:#00a000>height</span>(root.Left) <span style=color:#666>-</span> <span style=color:#00a000>height</span>(root.Right)
    <span style=color:#a2f;font-weight:700>if</span> t &gt; <span style=color:#666>1</span> <span style=color:#666>||</span> t &lt; <span style=color:#666>-</span><span style=color:#666>1</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span>      
    }
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>isBalanced</span>(root.Left) <span style=color:#666>&amp;&amp;</span> <span style=color:#00a000>isBalanced</span>(root.Right)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>height</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#0b0;font-weight:700>int</span> {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>
    }
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>max</span>(<span style=color:#00a000>height</span>(root.Left), <span style=color:#00a000>height</span>(root.Right))<span style=color:#666>+</span><span style=color:#666>1</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>max</span>(a,b <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
    <span style=color:#a2f;font-weight:700>if</span> a &gt; b {
        <span style=color:#a2f;font-weight:700>return</span> a
    }
    <span style=color:#a2f;font-weight:700>return</span> b
}
</code></pre></div><h2 id=3-平衡二叉搜索树>3. 平衡二叉搜索树</h2><p>平衡二叉搜索树的意义在于将针对二叉搜索树的算法复杂度限制到 O(logN)，因为二叉搜索树的复杂度通常为O(h)，最坏情况下，树成为链，树高将等于树中节点个数，我们将二叉搜索树调整为平衡的，就可以令树高最小，即 logN。</p><p>有许多方法可以实现平衡二叉搜索树，包括红黑树、AVL树、伸展树、树堆等。下面仅介绍 AVL 树，红黑树在后面的文章中介绍，不过在此之前，先介绍一个有意思的题型：将二叉搜索树变平衡。</p><h3 id=31-将二叉搜索树变平衡>3.1 将二叉搜索树变平衡</h3><p>给你一棵二叉搜索树，请你返回一棵 <strong>平衡后</strong> 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p><p>该题当然不是要我们利用后面的 AVL 或红黑树，而是要重复利用二叉搜索树这一个条件。思路很简单，就是将二叉搜索树利用中序遍历变为递增序列，然后以中间节点为根结点重新构造二叉搜索树，这是一个贪心的思路。最后实现的代码如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>/**
</span><span style=color:#080;font-style:italic> * Definition for a binary tree node.
</span><span style=color:#080;font-style:italic> * type TreeNode struct {
</span><span style=color:#080;font-style:italic> *     Val int
</span><span style=color:#080;font-style:italic> *     Left *TreeNode
</span><span style=color:#080;font-style:italic> *     Right *TreeNode
</span><span style=color:#080;font-style:italic> * }
</span><span style=color:#080;font-style:italic> */</span>
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>balanceBST</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
    <span style=color:#080;font-style:italic>// 先中序遍历排序
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span> root
    }
    <span style=color:#a2f;font-weight:700>var</span> seqList []<span style=color:#0b0;font-weight:700>int</span>
    <span style=color:#00a000>midOrder</span>(root, <span style=color:#666>&amp;</span>seqList)
    <span style=color:#080;font-style:italic>// 然后用二分法分别构建左右子树
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>build</span>(<span style=color:#666>0</span>, <span style=color:#a2f>len</span>(seqList) <span style=color:#666>-</span> <span style=color:#666>1</span>, seqList)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>midOrder</span>(root <span style=color:#666>*</span>TreeNode, list <span style=color:#666>*</span>[]<span style=color:#0b0;font-weight:700>int</span>) {
    <span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
        <span style=color:#a2f;font-weight:700>return</span>
    }
    <span style=color:#00a000>midOrder</span>(root.Left, list)
    <span style=color:#666>*</span>list = <span style=color:#a2f>append</span>(<span style=color:#666>*</span>list, root.Val)
    <span style=color:#00a000>midOrder</span>(root.Right, list)
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>build</span>(l, r <span style=color:#0b0;font-weight:700>int</span>, list []<span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>TreeNode {
    <span style=color:#a2f;font-weight:700>if</span> r &lt; l {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
    }
    mid <span style=color:#666>:=</span> (l <span style=color:#666>+</span> r) <span style=color:#666>&gt;&gt;</span> <span style=color:#666>2</span>
    root <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>TreeNode{Val: list[mid]}
    root.Left = <span style=color:#00a000>build</span>(l, mid <span style=color:#666>-</span> <span style=color:#666>1</span>, list)
    root.Right = <span style=color:#00a000>build</span>(mid <span style=color:#666>+</span> <span style=color:#666>1</span>, r, list)
    <span style=color:#a2f;font-weight:700>return</span> root
}

</code></pre></div><h3 id=32-avl树>3.2 AVL树</h3><p>AVL树是根据它的发明者G.M. <strong>A</strong>delson-<strong>V</strong>elsky和E.M. <strong>L</strong>andis命名的，它是最先发明的平衡二叉查找树。</p><p>由于AVL树同样是一颗二叉搜索树，插入和删除的算法和二叉搜索树相同，但是插入和删除结点后，会造成树高和平衡因子的变化，从而不满足平衡二叉树的条件，因此需要对其进行调整。</p><p>以插入为例，将所有情况和对应的处理措施分为四种</p><p><strong>RR</strong></p><p>意为插入的结点在失衡点右子树的右子树中（左右孩子处理办法都一样），其解决办法是进行一次<strong>左旋转</strong>，如下图所示，14为新插入的结点。需要注意的是失衡点不一定是根结点。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3kH9Fx.png alt=AVL树左旋转></p><p>简单的代码实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>leftRotate</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
	tmp <span style=color:#666>:=</span> root.Right
	root.Right = tmp.Left
	tmp.Left = root

	root.Height = <span style=color:#00a000>max</span>(<span style=color:#00a000>getHeight</span>(root.Left), <span style=color:#00a000>getHeight</span>(root.Right)) <span style=color:#666>+</span> <span style=color:#666>1</span>
	tmp.Height = <span style=color:#00a000>max</span>(<span style=color:#00a000>getHeight</span>(tmp.Left), <span style=color:#00a000>getHeight</span>(tmp.Right)) <span style=color:#666>+</span> <span style=color:#666>1</span>
	<span style=color:#a2f;font-weight:700>return</span> tmp
}
</code></pre></div><p><strong>RL</strong></p><p>意为插入的结点在失衡点右子树的左子树中（左右孩子都一样），其解决办法是<strong>先进行一次右旋转，再进行一次左旋转</strong>，如下图所示，插入结点分别为10.5和11.5</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3kOXZQ.png alt=AVL树先右后左旋转></p><p>简单的代码实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>rightThenLeftRotate</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
	tmp <span style=color:#666>:=</span> <span style=color:#00a000>rightRotate</span>(root.Right)
	root.Right = tmp
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>leftRotate</span>(root)
}
</code></pre></div><p><strong>LL</strong></p><p>意为插入的结点在失衡点左子树的左子树中（左右孩子都一样），其解决办法是进行一次<strong>右旋转</strong>，如下图所示，6为插入的新结点</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3kvTR1.png alt=AVL树右旋转></p><p>简单的代码实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>rightRotate</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
	tmp <span style=color:#666>:=</span> root.Left
	root.Left = tmp.Right
	tmp.Right = root

	root.Height = <span style=color:#00a000>max</span>(<span style=color:#00a000>getHeight</span>(root.Left), <span style=color:#00a000>getHeight</span>(root.Right)) <span style=color:#666>+</span> <span style=color:#666>1</span>
	tmp.Height = <span style=color:#00a000>max</span>(<span style=color:#00a000>getHeight</span>(tmp.Left), <span style=color:#00a000>getHeight</span>(tmp.Right)) <span style=color:#666>+</span> <span style=color:#666>1</span>
	<span style=color:#a2f;font-weight:700>return</span> tmp
}
</code></pre></div><p><strong>LR</strong></p><p>意为插入的结点在失衡点左子树的右子树中（左右孩子都一样），其解决办法是<strong>先进行一次左旋转，再进行一次右旋转</strong>，如下图所示，插入结点为8.5和9.5</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3Ahc9g.png alt=AVL树先左后右旋转></p><p>简单的代码实现</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>leftThenRightRotate</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
	tmp <span style=color:#666>:=</span> <span style=color:#00a000>leftRotate</span>(root.Left)
	root.Left = tmp
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>rightRotate</span>(root)
}
</code></pre></div><p>对于AVL树的所有操作都建立在这四个基本操作之上，在插入和删除操作完成后，调用调整函数，然后在调整函数中分情况调用这四个函数。调整函数的实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>ajust</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#666>*</span>TreeNode {
	<span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
	compare <span style=color:#666>:=</span> <span style=color:#00a000>getHeight</span>(root.Right) <span style=color:#666>-</span> <span style=color:#00a000>getHeight</span>(root.Left)
	<span style=color:#a2f;font-weight:700>if</span> compare <span style=color:#666>==</span> <span style=color:#666>2</span> {
		<span style=color:#a2f;font-weight:700>if</span> <span style=color:#00a000>getHeight</span>(root.Right.Right) &gt; <span style=color:#00a000>getHeight</span>(root.Right.Left) {
			root = <span style=color:#00a000>leftRotate</span>(root)
		} <span style=color:#a2f;font-weight:700>else</span> {
			root = <span style=color:#00a000>rightThenLeftRotate</span>(root)
		}
	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> compare <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>2</span> {
		<span style=color:#a2f;font-weight:700>if</span> <span style=color:#00a000>getHeight</span>(root.Left.Left) &gt; <span style=color:#00a000>getHeight</span>(root.Left.Right) {
			root = <span style=color:#00a000>rightRotate</span>(root)
		} <span style=color:#a2f;font-weight:700>else</span> {
			root = <span style=color:#00a000>leftThenRightRotate</span>(root)
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> root
}
</code></pre></div><p>其中用到寻找最大值和获取高度两个工具函数，实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>getHeight</span>(root <span style=color:#666>*</span>TreeNode) <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>if</span> root <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>
	}
	<span style=color:#a2f;font-weight:700>return</span> root.Height
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>max</span>(a <span style=color:#0b0;font-weight:700>int</span>, b <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>if</span> a &gt; b {
		<span style=color:#a2f;font-weight:700>return</span> a
	} <span style=color:#a2f;font-weight:700>else</span> {
		<span style=color:#a2f;font-weight:700>return</span> b
	}
}
</code></pre></div><h2 id=4-哈夫曼树>4. 哈夫曼树</h2><h3 id=41-定义>4.1 定义</h3><p>设二叉树有 n 个叶子结点，每个叶子结点带有权值 w<sub>k</sub>，从根结点到每个叶子结点的长度位 l<sub>k</sub>，则每个叶子结点的<strong>带权路径长度</strong>（WPL）之和为：
$$
WPL = \sum_{k=1}^{n} w_k l_k
$$
WPL 最小的二叉树就叫做哈夫曼树（或者最优二叉树）。其特点有</p><ul><li><p>没有度为1的结点</p></li><li><p>n个叶子结点的哈夫曼树共有2n-1个结点，因为对二叉树而言有$n_0=n_2+1$</p></li><li><p>哈夫曼树的任意非叶节点的左右子树交换后仍然是哈夫曼树</p></li><li><p>对同一组权值存在不同构的两棵哈夫曼树，例子如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3GlEwT.png alt=权值相同但不同构的哈夫曼树></p></li></ul><h3 id=42-构造>4.2 构造</h3><p>构造哈夫曼树的思路极为简单，即每次把权值最小的两棵二叉树合并，以{1，2，3，4，5}这组数为例，构造过程如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3G12VK.png alt=哈夫曼树构造过程></p><p>其构造的关键在于每次寻找剩余结点中的最小值，最简单的实现是使用堆</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> TreeNode <span style=color:#a2f;font-weight:700>struct</span> {
    Weight <span style=color:#0b0;font-weight:700>int</span>
    Left <span style=color:#666>*</span>TreeNode
    Right <span style=color:#666>*</span>TreeNode
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Huffman</span>(H MinHeap) {
    <span style=color:#080;font-style:italic>//假设MinHeap类型已实现标准库中堆的相关接口，H已存好所有权值
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>var</span> T TreeNode
    heap.<span style=color:#00a000>Init</span>(H)
    <span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; H.<span style=color:#00a000>Len</span>(); i<span style=color:#666>++</span> {
        T = TreeNode{}
        T.Left = H.<span style=color:#00a000>Pop</span>(H)
        T.Right = H.<span style=color:#00a000>Pop</span>(H)
        T.Weight = T.Left.Weight <span style=color:#666>+</span> T.Right.Weight
        H.<span style=color:#00a000>Push</span>(H, T)
    }
    T = H.<span style=color:#00a000>Pop</span>(H)
    <span style=color:#a2f;font-weight:700>return</span> T
}
</code></pre></div><h3 id=43-哈夫曼编码>4.3 哈夫曼编码</h3><p>该问题的描述为：给定一段字符串，如何堆字符进行编码，可以使得该字符串的编码存储空间最少</p><blockquote><p>例：假设有一段文本，包含58个字符，并由以下7个字符构成：a，e，i，s，t，空格(sp)，换行(nl)；这7个字符出现的次数不同，如何对这7个字符进行编码，可以使得总编码空间最少</p></blockquote><p>如果用等长ASCII编码，则一共 58×8=464 位；如果用等长3位编码，则一共 58×3=174位；最后一种方法是不等长编码，即出现频率高的字符编码短，出现频率低的字符编码长。</p><p>使用不等长编码时，为了避免二义性，可以使用前缀码（prefix code），即任何字符的编码都不是另一字符编码的前缀。将二叉树用于编码，遵循下面的规则</p><ul><li>左右分支：0，1</li><li>字符只在叶节点上</li></ul><p>假设四个字符的频率分别为：a-4, u-1, x-2, z-1，两个可用的编码树如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3GaWI1.png alt=编码树举例></p><table><thead><tr><th>字符</th><th>a</th><th>e</th><th>i</th><th>s</th><th>t</th><th>sp</th><th>nl</th></tr></thead><tbody><tr><td>权值</td><td>10</td><td>15</td><td>12</td><td>3</td><td>4</td><td>13</td><td>1</td></tr></tbody></table><p>按照构造哈夫曼树的方法，可以构造棵编码代价最小的二叉树，假设之前例子中的7个字符权值如上表，则可构造得到如下的哈夫曼编码树</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200303_3GB4TH.png alt=哈夫曼编码树></p><h2 id=参考资料>参考资料</h2><p>[1] <a href=https://blog.csdn.net/qq_36183935/article/details/80315808>CSDN-Golang实现平衡二叉树</a></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95 rel=tag title=数据结构与算法>#数据结构与算法#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-info><p><span>声明：</span>数据结构-二叉搜索树</p><p><span>链接：</span>https://shuzang.github.io/2020/03/data-structure-binary-search-tree/</p><p><span>作者：</span>书藏</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://shuzang.github.io/2020/03/%E9%9B%95%E5%88%80/ rel=next title=雕刀><i class="fa fa-chevron-left"></i>雕刀</a></div><div class="post-nav-prev post-nav-item"><a href=https://shuzang.github.io/2020/02/life-weekly-9/ rel=prev title="书藏的生活周刊第 9 期 (20200228)">书藏的生活周刊第 9 期 (20200228)
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2018 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer();});</script><script type=text/javascript>$(function(){if(detectIE()>0){$.getScript(document.location.protocol+'//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',function(){new Waline({el:'#wcomments',visitor:true,avatar:'wavatar',avatarCDN:'https://sdn.geekzu.org/avatar/',avatarForce:!1,wordLimit:'200',placeholder:' 欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^ ',requiredFields:['nick','mail'],serverURL:"Your WalineSerURL",lang:"zh-cn"});});}else{$('#wcomments').html('抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。');}});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>
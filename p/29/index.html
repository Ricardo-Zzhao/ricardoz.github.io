<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta name=generator content="Hugo 0.63.2"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="Home"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/author.jpg"><meta name=title content="Home - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a>
<span class=lang-line>/</span>
<a class=lang-link id=en href=https://shuzang.github.io/en/>English</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-active"><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/image-container-and-repository/ itemprop=url>Docker-镜像、容器与仓库</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-05-18">2020-05-18</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>爱编程爱技术的孩子</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>4760 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>10分钟</span></span></div></header><div class=post-body itemprop=articleBody><p>Docker 的三个基本概念是镜像（Image）、容器（Container）和仓库（Repository），理解了这三个概念基本就理解了 Docker。</p></div><div class="post-more-link text-center"><a class=btn href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/image-container-and-repository/ rel=contents>阅读全文 &#187;</a></div><footer class=post-footer><div class=post-eof></div></footer></article><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/summary-of-smart-contract-knowledge-points/ itemprop=url>智能合约知识点总结</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-05-04">2020-05-04</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF itemprop=url rel=index style=text-decoration:underline><span itemprop=name>研究生的区块链学习之路</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>4814 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>10分钟</span></span></div></header><div class=post-body itemprop=articleBody><p>项目进行过程中知识点的总结</p><h2 id=1-字符串比较>1. 字符串比较</h2><p>翻译自：<a href=https://fravoll.github.io/solidity-patterns/string_equality_comparison.html>Fravoll-String Equality Comparison</a></p><p>比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。</p><h3 id=11-stringutils-库>1.1 StringUtils 库</h3><p>第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。</p><h3 id=12-哈希函数>1.2 哈希函数</h3><p>作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下</p><ol><li>检查两个字符串是否有相同长度，通过转换为 <code>bytes</code> 类型完成，因为 <code>bytes</code> 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；</li><li>使用 <code>keccak256()</code> 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。</li></ol><p>一个示例代码如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span>#</span> <span>这</span><span>段</span><span>代</span><span>码</span><span>未</span><span>经</span><span>安</span><span>全</span><span>审</span><span>计</span><span>，</span><span>使</span><span>用</span><span>有</span><span>风</span><span>险</span>
<span style=color:#a2f;font-weight:700>function</span> hashCompareWithLengthCheck(<span style=color:#0b0;font-weight:700>string</span> a, <span style=color:#0b0;font-weight:700>string</span> b) <span style=color:#a2f;font-weight:700>internal</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>bool</span>) {
    <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#0b0;font-weight:700>bytes</span>(a).length <span style=color:#666>!=</span> <span style=color:#0b0;font-weight:700>bytes</span>(b).length) {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span>;
    } <span style=color:#a2f;font-weight:700>else</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>keccak256</span>(abi.encodePacket(a)) <span style=color:#666>==</span> <span style=color:#00a000>keccak256</span>(abi.encodePacket(b));
    }
}
</code></pre></div><p><code>abi.encodePacket(...) returns (bytes)</code> 用于对给定参数执行<a href=https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode>紧打包编码</a>，官方文档中不推荐使用 <code>keccak256(...)</code> 直接计算哈希，而是使用 <code>keccak256(abi.encodePacked(...))</code></p><h3 id=13-gas-消耗分析>1.3 Gas 消耗分析</h3><p>在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗</p><ol><li>比较哈希</li><li>比较每个字符，同时比较字符串长度</li><li>比较哈希，同时比较字符串长度</li></ol><p>结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei</p><table><thead><tr><th align=left>Input A</th><th align=left>Input B</th><th align=right>Hash</th><th align=right>Character + Length</th><th align=right>Hash + Length</th></tr></thead><tbody><tr><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=right>1225</td><td align=right>7062</td><td align=right>1261</td></tr><tr><td align=left>abcdefghijklmnopqrstuvwxy<strong>X</strong></td><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=right>1225</td><td align=right>7012</td><td align=right>1261</td></tr><tr><td align=left><strong>X</strong>bcdefghijklmnopqrstuvwxyz</td><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=right>1225</td><td align=right>912</td><td align=right>1261</td></tr><tr><td align=left>a<strong>X</strong>cdefghijklmnopqrstuvwxyz</td><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=right>1225</td><td align=right>1156</td><td align=right>1261</td></tr><tr><td align=left>ab<strong>X</strong>defghijklmnopqrstuvwxyz</td><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=right>1225</td><td align=right>1400</td><td align=right>1261</td></tr><tr><td align=left>abcdefghijkl</td><td align=left>abcdefghijklmnopqrstuvwxyz</td><td align=right>1225</td><td align=right>690</td><td align=right>707</td></tr><tr><td align=left>a</td><td align=left>a</td><td align=right>1225</td><td align=right>962</td><td align=right>1261</td></tr><tr><td align=left>ab</td><td align=left>ab</td><td align=right>1225</td><td align=right>1156</td><td align=right>1261</td></tr><tr><td align=left>abc</td><td align=left>abc</td><td align=right>1225</td><td align=right>1450</td><td align=right>1261</td></tr></tbody></table><p>可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。</p><h2 id=2-可见性与getter函数>2. 可见性与Getter函数</h2><p>转自：<a href=https://learnblockchain.cn/docs/solidity/contracts.html#getter>Solidity 0.6.4 中文文档</a></p><p>Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。</p><h3 id=21-可见性>2.1 可见性</h3><p>因此，函数和状态变量有四种可见性。函数可以指定为 <code>external</code>，<code>public</code>，<code>internal</code> 或 <code>private</code>，对于状态变量， 默认是 <code>internal</code> 且不能设置为 <code>external</code>。</p><ul><li><code>external</code>：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code>可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.</li><li><code>public</code>：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。</li><li><code>internal</code>：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</li><li><code>private</code>：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</li></ul><blockquote><p>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</p></blockquote><p>可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span>  <span style=color:#666>&gt;=</span><span style=color:#666>0</span>.<span style=color:#666>4</span>.<span style=color:#666>16</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> C {
    <span style=color:#a2f;font-weight:700>function</span> f(<span style=color:#0b0;font-weight:700>uint</span> a) <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>pure</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>uint</span> b) { <span style=color:#a2f;font-weight:700>return</span> a <span style=color:#666>+</span> <span style=color:#666>1</span>; }
    <span style=color:#a2f;font-weight:700>function</span> setData(<span style=color:#0b0;font-weight:700>uint</span> a) <span style=color:#a2f;font-weight:700>internal</span> { data <span style=color:#666>=</span> a; }
    <span style=color:#0b0;font-weight:700>uint</span> <span style=color:#a2f;font-weight:700>public</span> data;
}
</code></pre></div><p>在下面的例子中，<code>D</code> 可以调用 <code>c.getData（）</code> 来获取状态存储中 <code>data</code> 的值，但不能调用 <code>f</code> 。 合约 <code>E</code> 继承自 <code>C</code> ，因此可以调用 <code>compute</code>。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span> <span style=color:#666>&gt;=</span><span style=color:#666>0</span>.<span style=color:#666>4</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> C {
    <span style=color:#0b0;font-weight:700>uint</span> <span style=color:#a2f;font-weight:700>private</span> data;

    <span style=color:#a2f;font-weight:700>function</span> f(<span style=color:#0b0;font-weight:700>uint</span> a) <span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>returns</span>(<span style=color:#0b0;font-weight:700>uint</span> b) { <span style=color:#a2f;font-weight:700>return</span> a <span style=color:#666>+</span> <span style=color:#666>1</span>; }
    <span style=color:#a2f;font-weight:700>function</span> setData(<span style=color:#0b0;font-weight:700>uint</span> a) <span style=color:#a2f;font-weight:700>public</span> { data <span style=color:#666>=</span> a; }
    <span style=color:#a2f;font-weight:700>function</span> getData() <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>returns</span>(<span style=color:#0b0;font-weight:700>uint</span>) { <span style=color:#a2f;font-weight:700>return</span> data; }
    <span style=color:#a2f;font-weight:700>function</span> compute(<span style=color:#0b0;font-weight:700>uint</span> a, <span style=color:#0b0;font-weight:700>uint</span> b) <span style=color:#a2f;font-weight:700>internal</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>uint</span>) { <span style=color:#a2f;font-weight:700>return</span> a<span style=color:#666>+</span>b; }
}

<span style=color:#080;font-style:italic>// 下面代码编译错误
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>contract</span> D {
    <span style=color:#a2f;font-weight:700>function</span> readData() <span style=color:#a2f;font-weight:700>public</span> {
        C c <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> C();
        <span style=color:#0b0;font-weight:700>uint</span> local <span style=color:#666>=</span> c.f(<span style=color:#666>7</span>); <span style=color:#080;font-style:italic>// 错误：成员 `f` 不可见
</span><span style=color:#080;font-style:italic></span>        c.setData(<span style=color:#666>3</span>);
        local <span style=color:#666>=</span> c.getData();
        local <span style=color:#666>=</span> c.compute(<span style=color:#666>3</span>, <span style=color:#666>5</span>); <span style=color:#080;font-style:italic>// 错误：成员 `compute` 不可见
</span><span style=color:#080;font-style:italic></span>    }
}

<span style=color:#a2f;font-weight:700>contract</span> E <span style=color:#a2f;font-weight:700>is</span> C {
    <span style=color:#a2f;font-weight:700>function</span> g() <span style=color:#a2f;font-weight:700>public</span> {
        C c <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> C();
        <span style=color:#0b0;font-weight:700>uint</span> val <span style=color:#666>=</span> compute(<span style=color:#666>3</span>, <span style=color:#666>5</span>); <span style=color:#080;font-style:italic>// 访问内部成员（从继承合约访问父合约成员）
</span><span style=color:#080;font-style:italic></span>    }
}
</code></pre></div><h3 id=22-getter-函数>2.2 Getter 函数</h3><p>编译器自动为所有 <strong>public</strong> 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 <code>data</code> 的函数， 该函数没有参数，返回值是一个 <code>uint</code> 类型，即状态变量 <code>data</code> 的值。 状态变量的初始化可以在声明时完成。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span>  <span style=color:#666>&gt;=</span><span style=color:#666>0</span>.<span style=color:#666>4</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> C {
    <span style=color:#0b0;font-weight:700>uint</span> <span style=color:#a2f;font-weight:700>public</span> data <span style=color:#666>=</span> <span style=color:#666>42</span>;
}

<span style=color:#a2f;font-weight:700>contract</span> Caller {
    C c <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> C();
    <span style=color:#a2f;font-weight:700>function</span> f() <span style=color:#a2f;font-weight:700>public</span> {
        <span style=color:#0b0;font-weight:700>uint</span> local <span style=color:#666>=</span> c.data();
    }
}
</code></pre></div><p>getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 <code>this.</code> ），它被认为一个状态变量。 如果使用外部访问（即用 <code>this.</code> ），它被认作为一个函数。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span> <span style=color:#666>^</span><span style=color:#666>0</span>.<span style=color:#666>4</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> C {
    <span style=color:#0b0;font-weight:700>uint</span> <span style=color:#a2f;font-weight:700>public</span> data;
    <span style=color:#a2f;font-weight:700>function</span> x() <span style=color:#a2f;font-weight:700>public</span> {
        data <span style=color:#666>=</span> <span style=color:#666>3</span>; <span style=color:#080;font-style:italic>// 内部访问
</span><span style=color:#080;font-style:italic></span>        <span style=color:#0b0;font-weight:700>uint</span> val <span style=color:#666>=</span> <span style=color:#a2f>this</span>.data(); <span style=color:#080;font-style:italic>// 外部访问
</span><span style=color:#080;font-style:italic></span>    }
}
</code></pre></div><p>如果你有一个数组类型的 <code>public</code> 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 <code>data(0)</code> 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span> <span style=color:#666>&gt;=</span><span style=color:#666>0</span>.<span style=color:#666>4</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> arrayExample {
  <span style=color:#080;font-style:italic>// public state variable
</span><span style=color:#080;font-style:italic></span>  <span style=color:#0b0;font-weight:700>uint</span>[] <span style=color:#a2f;font-weight:700>public</span> myArray;

  <span style=color:#080;font-style:italic>// 指定生成的Getter 函数
</span><span style=color:#080;font-style:italic></span>  <span style=color:#080;font-style:italic>/*
</span><span style=color:#080;font-style:italic>  function myArray(uint i) public view returns (uint) {
</span><span style=color:#080;font-style:italic>      return myArray[i];
</span><span style=color:#080;font-style:italic>  }
</span><span style=color:#080;font-style:italic>  */</span>

  <span style=color:#080;font-style:italic>// 返回整个数组
</span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>function</span> getArray() <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>view</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>uint</span>[] <span style=color:#a2f;font-weight:700>memory</span>) {
      <span style=color:#a2f;font-weight:700>return</span> myArray;
  }
}
</code></pre></div><p>现在可以使用 <code>getArray()</code> 获得整个数组，而 <code>myArray(i)</code> 是返回单个元素。</p><p>下一个例子稍微复杂一些：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span> <span style=color:#666>^</span><span style=color:#666>0</span>.<span style=color:#666>4</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> Complex {
    <span style=color:#a2f;font-weight:700>struct</span> Data {
        <span style=color:#0b0;font-weight:700>uint</span> a;
        <span style=color:#0b0;font-weight:700>bytes3</span> b;
        <span style=color:#a2f;font-weight:700>mapping</span> (<span style=color:#0b0;font-weight:700>uint</span> <span style=color:#666>=&gt;</span> <span style=color:#0b0;font-weight:700>uint</span>) map;
    }
    <span style=color:#a2f;font-weight:700>mapping</span> (<span style=color:#0b0;font-weight:700>uint</span> <span style=color:#666>=&gt;</span> <span style=color:#a2f;font-weight:700>mapping</span>(<span style=color:#0b0;font-weight:700>bool</span> <span style=color:#666>=&gt;</span> Data[])) <span style=color:#a2f;font-weight:700>public</span> data;
}
</code></pre></div><p>这将会生成以下形式的函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>function</span> data(<span style=color:#0b0;font-weight:700>uint</span> arg1, <span style=color:#0b0;font-weight:700>bool</span> arg2, <span style=color:#0b0;font-weight:700>uint</span> arg3) <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>uint</span> a, <span style=color:#0b0;font-weight:700>bytes3</span> b) {
    a <span style=color:#666>=</span> data[arg1][arg2][arg3].a;
    b <span style=color:#666>=</span> data[arg1][arg2][arg3].b;
}
</code></pre></div><p>请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。</p><h2 id=3-合约间调用>3. 合约间调用</h2><p>之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况</p><ol><li>调用者和被调用者在一个sol文件中</li><li>调用者和被调用者在不同的sol文件中</li></ol><p>本文提到的合约调用方法的实质是抽象合约的使用。</p><h3 id=31-同sol文件的智能合约调用>3.1 同sol文件的智能合约调用</h3><p>下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>pragma solidity <span style=color:#666>^</span><span style=color:#666>0.5</span><span style=color:#666>.0</span>;


contract Main {
  Add add;
  
  constructor(address _m) <span style=color:#a2f;font-weight:700>public</span> {
     add <span style=color:#666>=</span> Add(_m);
  }
  
  <span style=color:#a2f;font-weight:700>function</span> Addnumber() <span style=color:#a2f;font-weight:700>public</span> view returns (uint) {
    <span style=color:#a2f;font-weight:700>return</span> add.add5(<span style=color:#666>10</span>);
  }
}

contract Add {
  <span style=color:#a2f;font-weight:700>function</span> add5(uint s) <span style=color:#a2f;font-weight:700>public</span> pure returns (uint){
      <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>5</span><span style=color:#666>+</span>s;
  }
}
</code></pre></div><p>以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472178-e6294d00-025a-11ea-8b4b-41a53b471c18.png alt=编译></p><p>然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击<code>Deploy</code>，成功部署后，复制合约地址。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472256-0e18b080-025b-11ea-9a24-e324c82cd7b5.png alt="deploy simple Add"></p><p>然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472285-1a047280-025b-11ea-8bb5-a1fb5c65574e.png alt="deploy simple Main"></p><p>测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的<code>Deployed Contracts</code>，点击Addnumber进行调用，结果如下。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472220-f5a89600-025a-11ea-9d2a-b39c8e39a810.png alt="call test"></p><h3 id=32-不同sol文件的智能合约调用>3.2 不同sol文件的智能合约调用</h3><p>这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。</p><p>Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>pragma solidity <span style=color:#666>^</span><span style=color:#666>0.5</span><span style=color:#666>.0</span>;

contract Add {
    struct Num{
        uint value;
    }
    mapping(uint =&gt; Num) <span style=color:#a2f;font-weight:700>public</span> lookupTable;
    
    <span style=color:#a2f;font-weight:700>function</span> numRegister(uint key, uint _value) <span style=color:#a2f;font-weight:700>public</span> {
        lookupTable[key].value <span style=color:#666>=</span> _value;
    }
    
    <span style=color:#a2f;font-weight:700>function</span> addValue(uint key) <span style=color:#a2f;font-weight:700>public</span> view returns (uint) {
        <span style=color:#a2f;font-weight:700>return</span> lookupTable[key].value <span style=color:#666>+</span> <span style=color:#666>5</span>;
    }

}
</code></pre></div><p>Main.sol没有多大变化</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>pragma solidity <span style=color:#666>^</span><span style=color:#666>0.5</span><span style=color:#666>.0</span>;

contract Main {
  Add add;
  
  constructor(address _m) <span style=color:#a2f;font-weight:700>public</span> {
     add <span style=color:#666>=</span> Add(_m);
  }
  
  <span style=color:#a2f;font-weight:700>function</span> Addnumber() <span style=color:#a2f;font-weight:700>public</span> view returns (uint) {
    <span style=color:#a2f;font-weight:700>return</span> add.addValue(<span style=color:#666>5</span>);
  }
}

contract Add {
      <span style=color:#a2f;font-weight:700>function</span> addValue(uint key) <span style=color:#a2f;font-weight:700>public</span> view returns (uint);
}
</code></pre></div><p>仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472316-2d174280-025b-11ea-96a6-51af8dd4fd4c.png alt="deploy comlex Add"></p><p>接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472331-399b9b00-025b-11ea-933f-8c03ff95c55a.png alt="deploy comlex Main"></p><h3 id=33-总结>3.3 总结</h3><p>合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用<code>call</code>，<code>callcode</code>或<code>delegatecall</code>，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。</p><p>详细的解释参考了<a href=https://ethereum.stackexchange.com/questions/9733/calling-function-from-deployed-contract>StackExchange-Calling function from deployed contract</a></p><h2 id=4-函数修饰词pure和view>4. 函数修饰词pure和view</h2><p>转自<a href=https://learnblockchain.cn/docs/solidity/contracts.html#view>深入理解Solidity-函数</a></p><p>这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。</p><h3 id=41-view-视图函数>4.1 view 视图函数</h3><p>Getter 方法会被自动标记为 <code>view</code>，除此之外，一个 view 修饰的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span>  <span style=color:#666>&gt;=</span><span style=color:#666>0</span>.<span style=color:#666>5</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> C {
    <span style=color:#a2f;font-weight:700>function</span> f(<span style=color:#0b0;font-weight:700>uint</span> a, <span style=color:#0b0;font-weight:700>uint</span> b) <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>view</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>uint</span>) {
        <span style=color:#a2f;font-weight:700>return</span> a <span style=color:#666>*</span> (b <span style=color:#666>+</span> <span style=color:#666>42</span>) <span style=color:#666>+</span> <span style=color:#a2f>now</span>;
    }
}
</code></pre></div><p>view 保证函数不修改状态，以下操作会被认为是修改状态</p><ol><li>修改状态变量。</li><li>产生事件。</li><li>创建其它合约。</li><li>使用 <code>selfdestruct</code>。</li><li>通过调用发送以太币。</li><li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li><li>使用低级调用。</li><li>使用包含特定操作码的内联汇编。</li></ol><h3 id=42-pure-纯函数>4.2 pure 纯函数</h3><p>pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态</p><ol><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或者 <code>.balance</code>。</li><li>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含某些操作码的内联汇编。</li></ol><p>一个 pure 修饰的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=color:#a2f;font-weight:700>pragma solidity</span> <span style=color:#666>&gt;=</span><span style=color:#666>0</span>.<span style=color:#666>5</span>.<span style=color:#666>0</span> <span style=color:#666>&lt;</span><span style=color:#666>0</span>.<span style=color:#666>7</span>.<span style=color:#666>0</span>;

<span style=color:#a2f;font-weight:700>contract</span> C {
    <span style=color:#a2f;font-weight:700>function</span> f(<span style=color:#0b0;font-weight:700>uint</span> a, <span style=color:#0b0;font-weight:700>uint</span> b) <span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>pure</span> <span style=color:#a2f;font-weight:700>returns</span> (<span style=color:#0b0;font-weight:700>uint</span>) {
        <span style=color:#a2f;font-weight:700>return</span> a <span style=color:#666>*</span> (b <span style=color:#666>+</span> <span style=color:#666>42</span>);
    }
}
</code></pre></div><h2 id=5-浮点数处理>5. 浮点数处理</h2><p>首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。</p><ol><li>来自 <a href=https://ethereum.stackexchange.com/questions/83785/what-fixed-or-float-point-math-libraries-are-available-in-solidity>ethereum stackexchange</a> 中的回答，介绍了一些可用的库；</li><li><a href=https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md>ABDK Math Quad</a>，包含两个合约库，一个支持定点数，一个支持浮点数；</li><li>Mikhail Vladimirov 的 <a href=https://medium.com/coinmonks/math-in-solidity-part-1-numbers-384c8377f26d>Math in Solidity</a> 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。</li></ol><h2 id=6-地址类型>6. 地址类型</h2><p>在智能合约中显式传入地址类型时，可能会出现如下错误</p><blockquote><p>Address checksum</p><p>This looks like an address but has an invalid checksum. If this is not used as an address, please prepend &lsquo;00&rsquo;.</p></blockquote><p>关于该问题的一个讨论见 <a href=https://github.com/ethereum/EIPs/issues/55>https://github.com/ethereum/EIPs/issues/55</a></p><p>这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 <a href=https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md>ethereum/EIPs#55</a></p><p>但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个<a href=https://web3-tools.netlify.com/>在线API接口</a>，可以调用其<code>checkAddressChecksum</code>函数对地址进行转换，然后将转换后的结果直接用于合约代码。</p><h2 id=7-gas-limit问题>7. Gas limit问题</h2><p>在搭建的以太坊私链上进行智能合约部署时，出现了以下问题</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>INFO [<span style=color:#666>03</span><span style=color:#666>-</span><span style=color:#666>21</span><span style=color:#666>|</span><span style=color:#666>13</span><span style=color:#666>:</span><span style=color:#666>50</span><span style=color:#666>:</span><span style=color:#666>11.690</span>] Served eth_sendTransaction               reqid<span style=color:#666>=</span><span style=color:#666>24</span> t<span style=color:#666>=</span><span style=color:#666>684.186</span>µs    err<span style=color:#666>=</span><span style=color:#b44>&#34;exceeds block gas limit&#34;</span>
<span style=color:#a2f>Error</span><span style=color:#666>:</span> exceeds block gas limit <span style=color:#a2f;font-weight:700>undefined</span>
</code></pre></div><p>出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为<code>0x2fefd8</code>，转换为10进制即<code>3141592</code>。</p><p>注：<a href=http://tool.oschina.net/hexconvert/>在线转换工具</a></p></div><div class="post-more-link text-center"><a class=btn href=https://shuzang.github.io/post/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/summary-of-smart-contract-knowledge-points/ rel=contents>阅读全文 &#187;</a></div><footer class=post-footer><div class=post-eof></div></footer></article><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/algorithm-backtracking/ itemprop=url>算法-回溯</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-05-04">2020-05-04</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>爱编程爱技术的孩子</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>3442 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>7分钟</span></span></div></header><div class=post-body itemprop=articleBody>在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra</div><div class="post-more-link text-center"><a class=btn href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/algorithm-backtracking/ rel=contents>阅读全文 &#187;</a></div><footer class=post-footer><div class=post-eof></div></footer></article><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/algorithm-greedu/ itemprop=url>算法-贪心</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-05-03">2020-05-03</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>爱编程爱技术的孩子</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>1199 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>3分钟</span></span></div></header><div class=post-body itemprop=articleBody><p>贪心是一种策略，是一种总是寻求当前最优的策略。因为贪心只关心局部的最优，因此不是总能得到全局的最优解，所以我们选择贪心解决问题时必须保证状态的独立性，即当前最优值只与当前状态有关，不会影响以后的状态。</p></div><div class="post-more-link text-center"><a class=btn href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/algorithm-greedu/ rel=contents>阅读全文 &#187;</a></div><footer class=post-footer><div class=post-eof></div></footer></article><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/algorithm-dynamic-programming/ itemprop=url>算法-动态规划</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-05-01">2020-05-01</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90 itemprop=url rel=index style=text-decoration:underline><span itemprop=name>爱编程爱技术的孩子</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>2980 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>6分钟</span></span></div></header><div class=post-body itemprop=articleBody><p>动态规划策略通常用于求解最优化问题。在这类问题中，可能会有许多可行解，每个解对应一个值，我们希望找到具有最优值的那个解，也就是最优解。当题目中涉及「最大」「最小」等词时，很有可能就是这类问题，要考虑是否可用动态规划求解。</p></div><div class="post-more-link text-center"><a class=btn href=https://shuzang.github.io/post/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/algorithm-dynamic-programming/ rel=contents>阅读全文 &#187;</a></div><footer class=post-footer><div class=post-eof></div></footer></article></section><nav class=pagination><a class="extend prev" rel=prev href=/p/28/><i class="fa fa-angle-left"></i></a><a class=page-number href=/p/25/>25</a>
<a class=page-number href=/p/26/>26</a>
<a class=page-number href=/p/27/>27</a>
<a class=page-number href=/p/28/>28</a>
<span class="page-number current">29</span>
<a class=page-number href=/p/30/>30</a>
<a class=page-number href=/p/31/>31</a>
<a class=page-number href=/p/32/>32</a>
<a class=page-number href=/p/33/>33</a>
<a class="extend next" rel=next href=/p/30/><i class="fa fa-angle-right"></i></a></nav></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="feed-link motion-element"><a href=/index.xml rel=alternate type=application/rss+xml target=_blank><i class="fa fa-rss"></i>RSS 订阅</a></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://www.ucloud.cn/ style=font-weight:700 target=_blank>UCloud云存储</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href target=_blank></a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>
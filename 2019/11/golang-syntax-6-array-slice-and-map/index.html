<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Golang语法基础6-数组、切片与映射 - 书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="Golang语法基础6-数组、切片与映射"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/avatar.png"><meta name=title content="Golang语法基础6-数组、切片与映射 - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/2019/11/golang-syntax-6-array-slice-and-map/ itemprop=url>Golang语法基础6-数组、切片与映射</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2019-11-18">2019-11-18</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF itemprop=url rel=index style=text-decoration:underline><span itemprop=name>Golang学习之路</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>4687 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>10分钟</span></span>
<span id=/2019/11/golang-syntax-6-array-slice-and-map/ class=leancloud_visitors data-flag-title=Golang语法基础6-数组、切片与映射>|
<i class="fa fa-binoculars fa-fw"></i><span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>只有基本的数据类型无法适应所有的情况，当需要存储和处理大量数据时，通常会使用数组、映射、链表等数据结构，称之为容器(container)。在Go语言中，由于数组不够灵活，增加了切片(slice)类型，切片也是一种容器。</p><p>C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。</p><p>本篇只介绍数组和切片，映射类型放在下篇介绍，链表类型在数据结构中介绍。</p><h2 id=1-数组>1. 数组</h2><p>数组是有限个相同类型的数据的集合，Go语言中数组声明的格式为</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> identifier [len]<span style=color:#a2f;font-weight:700>type</span>
</code></pre></div><p>数组元素可以是任意基本类型，数组本身，结构体甚至接口（空），当元素类型是数组本身时，即为二维或多维数组。</p><p>应注意，数组长度也是数组类型的一部分，<code>[5]int</code>和<code>[10]int</code>是两个不同类型。</p><p>数组元素通过索引来读取或修改，不同于字符串，数组是可变的。索引的范围从<code>0</code>到<code>len(arr)-1</code>，内置函数<code>len()</code>可用来获取数组长度，数组长度最大为2Gb。</p><p>声明数组时所有的元素都会被自动初始化为元素类型的零值，初始化的过程是按照数组元素的顺序进行的。</p><p>当数组元素较少时，可以在声明时直接进行初始化，一些表达方式如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> arr1 = [<span style=color:#666>3</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
<span style=color:#a2f;font-weight:700>var</span> arr2 = [<span style=color:#666>10</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>} <span style=color:#080;font-style:italic>//剩下的元素会自动补全，其值为0
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> arr3 = [<span style=color:#666>3</span>]<span style=color:#0b0;font-weight:700>string</span>{<span style=color:#666>2</span>:<span style=color:#b44>&#34;test&#34;</span>}  <span style=color:#080;font-style:italic>//只有索引2被赋予了实际的值，其它元素都初始化为空字符串
</span></code></pre></div><p>数组长度的位置也可以使用省略号，此时数组长度会根据提供的值的个数自动推断</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>arr <span style=color:#666>:=</span> [<span style=color:#666>...</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
fmt.<span style=color:#00a000>Println</span>(<span style=color:#a2f>len</span>(arr)) <span style=color:#080;font-style:italic>//3
</span></code></pre></div><p>数组元素较多时使用for循环初始化</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> arr [<span style=color:#666>100</span>]<span style=color:#0b0;font-weight:700>int</span>

<span style=color:#080;font-style:italic>//使用for循环初始化
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>for</span> i<span style=color:#666>:=</span><span style=color:#666>0</span>; i &lt; <span style=color:#a2f>len</span>(arr); i<span style=color:#666>++</span> {
    arr[i] = i <span style=color:#666>*</span> <span style=color:#666>2</span>
}
</code></pre></div><p>Go语言中数组是一种值类型，而不像C语言是指向首元素的指针，因此可以使用内置函数<code>new()</code>来创建数组（<code>new()</code>用来创建值类型，返回所创建类型的指针）</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> arr1 = <span style=color:#a2f>new</span>([<span style=color:#666>5</span>]<span style=color:#0b0;font-weight:700>int</span>)
</code></pre></div><p>这种方式和<code>var arr2 [5]int</code>的区别是，arr1的类型是<code>*[5]int</code>，而arr2的类型是<code>[5]int</code>，一个简单的式子可以帮助理解</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>arr2 <span style=color:#666>:=</span> <span style=color:#666>*</span>arr1
</code></pre></div><p>当像上式这样进行赋值时，我们把arr1的值做了一次拷贝，因此修改arr2不会对arr1产生影响。同理，函数中数组作为参数传入时，传入值类型的数组不会改变原值，但是直接传入数组作为参数，当数组很大时会消耗很多内存，可以传入数组的指针或使用切片来解决。以下是传入指针的例子。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>f</span>(a [<span style=color:#666>3</span>]<span style=color:#0b0;font-weight:700>int</span>) { fmt.<span style=color:#00a000>Println</span>(a) }
<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>fp</span>(a <span style=color:#666>*</span>[<span style=color:#666>3</span>]<span style=color:#0b0;font-weight:700>int</span>) { fmt.<span style=color:#00a000>Println</span>(a) }

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    <span style=color:#a2f;font-weight:700>var</span> ar = [<span style=color:#666>3</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>} 
	<span style=color:#00a000>f</span>(ar) 	<span style=color:#080;font-style:italic>// passes a copy of ar
</span><span style=color:#080;font-style:italic></span>	<span style=color:#00a000>fp</span>(<span style=color:#666>&amp;</span>ar) <span style=color:#080;font-style:italic>// passes a pointer to ar
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>数组可以组装成多维数组，一个二维数组可以理解为一个数组类型的数组，以下演示一个二维数组的声明</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// 声明一个二维整型数组，两个维度的长度分别是 4 和 2
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> array [<span style=color:#666>4</span>][<span style=color:#666>2</span>]<span style=color:#0b0;font-weight:700>int</span>
<span style=color:#080;font-style:italic>// 声明并初始化数组中索引为 1 和 3 的元素
</span><span style=color:#080;font-style:italic></span>array = [<span style=color:#666>4</span>][<span style=color:#666>2</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>: {<span style=color:#666>20</span>, <span style=color:#666>21</span>}, <span style=color:#666>3</span>: {<span style=color:#666>40</span>, <span style=color:#666>41</span>}}
<span style=color:#080;font-style:italic>// 声明并初始化数组中指定的元素
</span><span style=color:#080;font-style:italic></span>array = [<span style=color:#666>4</span>][<span style=color:#666>2</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>: {<span style=color:#666>0</span>: <span style=color:#666>20</span>}, <span style=color:#666>3</span>: {<span style=color:#666>1</span>: <span style=color:#666>41</span>}}
</code></pre></div><h2 id=2-切片>2. 切片</h2><p>切片（slice）就是动态数组，可以理解为对数组一个连续片段的引用，是一个引用类型。</p><h3 id=21-声明与使用>2.1 声明与使用</h3><p>切片声明的格式如下，基本就是去掉了数组声明中的长度</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> identifier []<span style=color:#a2f;font-weight:700>type</span>
</code></pre></div><p>未初始化的切片默认为nil，长度为0。切片的初始化格式为</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> slice []<span style=color:#a2f;font-weight:700>type</span> = arr[start:end]
</code></pre></div><p>表示slice是数组arr从start索引到end-1索引之间的元素构成的子集，切片的大小可以和数组相等，但应注意到终止索引的项并不包含在切片内。一些切片的方式如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> arr = [<span style=color:#666>5</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>,<span style=color:#666>2</span>,<span style=color:#666>3</span>,<span style=color:#666>4</span>,<span style=color:#666>5</span>}

s <span style=color:#666>:=</span> arr[:] 
s <span style=color:#666>:=</span> arr[<span style=color:#666>0</span>:<span style=color:#666>5</span>] <span style=color:#080;font-style:italic>//这两个切片都等于整个数组
</span><span style=color:#080;font-style:italic></span>
s <span style=color:#666>:=</span> arr[:<span style=color:#666>3</span>]
s <span style=color:#666>:=</span> arr[<span style=color:#666>0</span>:<span style=color:#666>3</span>] <span style=color:#080;font-style:italic>//这两式输出都是[1,2,3]
</span><span style=color:#080;font-style:italic></span>
s <span style=color:#666>:=</span> arr[<span style=color:#666>2</span>:] 
s <span style=color:#666>:=</span> arr[<span style=color:#666>2</span>:<span style=color:#666>5</span>] <span style=color:#080;font-style:italic>//这两式输出都是[3,4,5]
</span></code></pre></div><p>切片是可索引的，但切片的索引与原数组的索引不一定相同，如上例最后一行，s[0] = arr[2]。</p><p>切片的长度在运行时可修改，最小为0最大为相关数组的长度，具体的长度值可通过<code>len()</code>函数获得。</p><p><code>cap()</code>函数可以计算切片的容量，也就是切片最长可以达到多少。举个例子，如果 s 是一个切片，<code>cap(s)</code> 就是从 <code>s[0]</code> 到数组末尾的数组长度。切片的长度永远不会超过它的容量。容量之所以从s[0]开始计数，是因为切片只能向后移动，任何试图获取切片第一个元素之前的数组元素的做法都会导致编译错误。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>arr <span style=color:#666>:=</span> [<span style=color:#666>5</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>, <span style=color:#666>4</span>, <span style=color:#666>5</span>}
s <span style=color:#666>:=</span> arr[<span style=color:#666>2</span>:<span style=color:#666>4</span>] <span style=color:#080;font-style:italic>//len(s)为2，cap(s)为3
</span></code></pre></div><p>两个直接创建切片的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>s <span style=color:#666>:=</span> [<span style=color:#666>3</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>,<span style=color:#666>2</span>,<span style=color:#666>3</span>}[:]
x <span style=color:#666>:=</span> []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>2</span>,<span style=color:#666>3</span>,<span style=color:#666>4</span>,<span style=color:#666>5</span>,<span style=color:#666>6</span>}
</code></pre></div><p>但本质上这两者都是先创建的数组，然后取了与数组等长的切片。</p><p>注：切片本身已是引用，它没有指针，因此不要对它使用取地址符。</p><p>在上面的数组部分我们谈到当数组很大时，直接将数组作为参数传给函数会占用大量内存，因此我们介绍了如何传入数组的指针，这里我们再介绍如何传入切片：我们应当在函数中声明参数为切片类型，调用函数时，把数组分片，创建一个切片引用传递给该函数，示例如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>sum</span>(a []<span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
	s <span style=color:#666>:=</span> <span style=color:#666>0</span>
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; <span style=color:#a2f>len</span>(a); i<span style=color:#666>++</span> {
		s <span style=color:#666>+=</span> a[i]
	}
	<span style=color:#a2f;font-weight:700>return</span> s
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#a2f;font-weight:700>var</span> arr = [<span style=color:#666>5</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>0</span>, <span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>, <span style=color:#666>4</span>}
	<span style=color:#00a000>sum</span>(arr[:])
}
</code></pre></div><p>数组作为值类型使用<code>new()</code>来创建，而切片作为引用类型，需要使用<code>make()</code>。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> slice []<span style=color:#a2f;font-weight:700>type</span> = <span style=color:#a2f>make</span>([]<span style=color:#a2f;font-weight:700>type</span>, len)
slice <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#a2f;font-weight:700>type</span>, len) <span style=color:#080;font-style:italic>//简写形式
</span></code></pre></div><p>其中第二个参数len是数组的长度，也是slice的初始长度，例如定义<code>s1 := make([]int, 10)</code>，那么<code>cap(s1) == len(s1) == 10</code></p><p>也可以在声明时利用第三个参数指定切片容量</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>slice <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#a2f;font-weight:700>type</span>, len, cap)
</code></pre></div><p>因此，下面两种方法可生成相同切片</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>50</span>, <span style=color:#666>100</span>)
<span style=color:#a2f>new</span>([<span style=color:#666>100</span>]<span style=color:#0b0;font-weight:700>int</span>)[<span style=color:#666>0</span>:<span style=color:#666>50</span>]
</code></pre></div><p>字符串可以看作是一个不可变的字节数组，因此也可以切分为切片使用。</p><h3 id=22-常用操作>2.2 常用操作</h3><p>由于切片的灵活性，会经常使用切片进行一些操作，这里简单介绍几种。</p><h4 id=重组>重组</h4><p>使用<code>make</code>创建切片的时候可以指定容量，因此必要时可以改变切片长度直到达到容量上限，改变切片长度的过程称为切片重组（reslice），如将切片扩展1位</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>s = s[<span style=color:#666>0</span>:<span style=color:#a2f>len</span>(s)<span style=color:#666>+</span><span style=color:#666>1</span>] <span style=color:#080;font-style:italic>//len(s)+1 &lt;= cap(s)
</span></code></pre></div><h4 id=复制>复制</h4><p>增加切片的容量必须创建一个新的更大的切片并把原分片的内容都拷贝过来。切片拷贝使用<code>copy()</code>函数，函数原型如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f>copy</span>(destSlice, srcSlice []T) <span style=color:#0b0;font-weight:700>int</span>
</code></pre></div><p>作用是将 srcSlice 复制到 destSlice，两者类型必须一致，返回值为实际复制的元素个数。源地址和目标地址可能会有重叠。复制的元素个数是 srcSlice 和 dstSlice 的长度最小值。示例如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>sl_from <span style=color:#666>:=</span> []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
sl_to1 <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>5</span>)
sl_to2 <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>2</span>)
n1 <span style=color:#666>:=</span> <span style=color:#a2f>copy</span>(sl_to1, sl_from) <span style=color:#080;font-style:italic>// n1 = 3, s1_to1 = [1,2,3,0,0]
</span><span style=color:#080;font-style:italic></span>n2 <span style=color:#666>:=</span> <span style=color:#a2f>copy</span>(sl_to2, sl_from) <span style=color:#080;font-style:italic>// n2 = 2, s1_to2 = [1,2]
</span></code></pre></div><h4 id=追加>追加</h4><p>追加也是一种切片扩容的方式，主要使用<code>append()</code>函数，函数原型是</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#a2f>append</span>(s []T, x <span style=color:#666>...</span>T) []T
</code></pre></div><p>作用是将0个或多个具有相同类型T的元素追加到切片s后面病并回新的切片，追加的元素类型需要和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>sl3 <span style=color:#666>:=</span> []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
sl3 = <span style=color:#a2f>append</span>(sl3, <span style=color:#666>4</span>, <span style=color:#666>5</span>, <span style=color:#666>6</span>) <span style=color:#080;font-style:italic>// sl2 = [1,2,3,4,5,6]
</span></code></pre></div><h4 id=删除>删除</h4><p>删除切片元素没有专用语法，需要使用切片本身的特性。分为三种情况：从开始位置删除，从中间位置删除，从末尾删除</p><p><strong>从开始位置删除</strong></p><p>直接移动数据指针</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a = []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
a = a[<span style=color:#666>1</span>:] <span style=color:#080;font-style:italic>// 删除开头1个元素
</span><span style=color:#080;font-style:italic></span>a = a[N:] <span style=color:#080;font-style:italic>// 删除开头N个元素
</span></code></pre></div><p>不移动数据指针，而是将后面的数据向开头移动</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a = []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
a = <span style=color:#a2f>append</span>(a[:<span style=color:#666>0</span>], a[<span style=color:#666>1</span>:]<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>// 删除开头1个元素
</span><span style=color:#080;font-style:italic></span>a = <span style=color:#a2f>append</span>(a[:<span style=color:#666>0</span>], a[N:]<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>// 删除开头N个元素
</span></code></pre></div><p>使用<code>copy()</code>函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a = []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
a = a[:<span style=color:#a2f>copy</span>(a, a[<span style=color:#666>1</span>:])] <span style=color:#080;font-style:italic>// 删除开头1个元素
</span><span style=color:#080;font-style:italic></span>a = a[:<span style=color:#a2f>copy</span>(a, a[N:])] <span style=color:#080;font-style:italic>// 删除开头N个元素
</span></code></pre></div><p><strong>从中间位置删除</strong></p><p>对剩余的元素做一次整体移动，可以使用<code>copy()</code>或<code>append()</code></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a = []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>, <span style=color:#666>...</span>}
a = <span style=color:#a2f>append</span>(a[:i], a[i<span style=color:#666>+</span><span style=color:#666>1</span>:]<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>// 删除中间1个元素
</span><span style=color:#080;font-style:italic></span>a = <span style=color:#a2f>append</span>(a[:i], a[i<span style=color:#666>+</span>N:]<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>// 删除中间N个元素
</span><span style=color:#080;font-style:italic></span>a = a[:i<span style=color:#666>+</span><span style=color:#a2f>copy</span>(a[i:], a[i<span style=color:#666>+</span><span style=color:#666>1</span>:])] <span style=color:#080;font-style:italic>// 删除中间1个元素
</span><span style=color:#080;font-style:italic></span>a = a[:i<span style=color:#666>+</span><span style=color:#a2f>copy</span>(a[i:], a[i<span style=color:#666>+</span>N:])] <span style=color:#080;font-style:italic>// 删除中间N个元素
</span></code></pre></div><p><strong>从末尾删除</strong></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a = []<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}
a = a[:<span style=color:#a2f>len</span>(a)<span style=color:#666>-</span><span style=color:#666>1</span>] <span style=color:#080;font-style:italic>// 删除尾部1个元素
</span><span style=color:#080;font-style:italic></span>a = a[:<span style=color:#a2f>len</span>(a)<span style=color:#666>-</span>N] <span style=color:#080;font-style:italic>// 删除尾部N个元素
</span></code></pre></div><p>删除开头和末尾都是删除中间的特殊情况</p><h4 id=插入>插入</h4><p>插入的一般方式是使用两次<code>append()</code>函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a = <span style=color:#a2f>append</span>(a[:i], <span style=color:#a2f>append</span>([]T{x}, a[i:]<span style=color:#666>...</span>)<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>//在索引i的位置插入元素x
</span><span style=color:#080;font-style:italic></span>a = <span style=color:#a2f>append</span>(a[:i], <span style=color:#a2f>append</span>(<span style=color:#a2f>make</span>([]T, j), a[i:]<span style=color:#666>...</span>)<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>//在索引i的位置插入长度为j的新切片
</span><span style=color:#080;font-style:italic></span>a = <span style=color:#a2f>append</span>(a[:i], <span style=color:#a2f>append</span>(b, a[i:]<span style=color:#666>...</span>)<span style=color:#666>...</span>) <span style=color:#080;font-style:italic>//在索引i的位置插入切片b的所有元素
</span></code></pre></div><p>映射(map)其实就是数据结构里的哈希表，但不少语言都已经把它作为了内置的数据类型。映射是元素对的无序集合，由键(key)和值(value)两部分构成，可以通过键快速查找值（比线性查找快，但实际上比通过数组或切片索引直接读取要慢）。</p><h2 id=3-映射>3. 映射</h2><h3 id=31--声明与初始化>3.1 声明与初始化</h3><p>Golang 中的 map 是引用类型，声明方法如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>//语法格式
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> mapname <span style=color:#a2f;font-weight:700>map</span>[keytype]valuetype
<span style=color:#080;font-style:italic>//示例
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> map1 <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>
</code></pre></div><p>凡是可以用 <code>==</code> 或 <code>!=</code> 操作符比较的类型都可以作为<strong>键的类型</strong>，比如string、int、float、只包含基本类型的结构体、指针和接口，而数组、切片以及含有数组切片的结构体无法作为键类型。<strong>值的类型</strong>是任意的，当值类型是一些复杂结构时，往往有比较特殊的用途，比如</p><ol><li><p>函数。值类型为函数时可以视作分支结构，key用来选择要执行的函数。</p></li><li><p>空接口。我们可以用空接口作为值类型存储任意类型的值，只是在使用前需要做一次类型断言。</p></li><li><p>切片。通过将值类型定义为切片类型，应对一个Key对应多个值的情况，示例如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>mp1 <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>int</span>][]<span style=color:#0b0;font-weight:700>int</span>)
</code></pre></div></li></ol><p>map 可以动态增长，声明时不关心长度，使用时其长度使用内置函数<code>len()</code>获取。</p><p>未初始化的 map 值为 nil，如果此时试图给map添加元素会导致运行时错误，因此添加元素必须首先初始化。map初始化的方法有两种</p><ol><li><p>直接使用大括号，在数组与切片的初始化中已经见过这种方法，示例如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> mapLit <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>
mapLit = <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#b44>&#34;one&#34;</span>:<span style=color:#666>1</span>, <span style=color:#b44>&#34;two&#34;</span>:<span style=color:#666>2</span>}
</code></pre></div></li><li><p>使用make，map是引用类型，因此使用make初始化。以make方式初始化其实相当于<code>mapLit := map[string]int{}</code></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>mapLit <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>)
</code></pre></div></li></ol><p>虽然map可以动态增长，没有长度限制，但是也可以在一开始标明其初始容量</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>mapLit <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>100</span>)
</code></pre></div><p>当map增长到容量上限后，继续增加新的键值对，map的大小会自动加1，因此容量对map并没有多大影响。</p><h3 id=32-访问与删除map中的元素>3.2 访问与删除map中的元素</h3><p>如果 key1 是 map1 的 key，那么 <code>map1[key1]</code> 就是对应 key1 的值，map中就通过这种类似数组索引的方式访问元素</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>val1 <span style=color:#666>:=</span> map1[key1]
</code></pre></div><p>上式将 key1 对应的值赋给了 val1，但反过来，也可以通过这种形式设置对应key1的值，如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>map1[key1] = val1
</code></pre></div><p>访问 map 中不存在的 key 会获得它所对应的值类型的空值，因此我们还需要有一种办法来判断键值对是否存在，这样才能区分到底是键值对本身不存在，还是值是空值。实际上通过键来访问值会返回两个结果，如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>val1, ok <span style=color:#666>:=</span> map1[key1]
</code></pre></div><p>当键值对存在时，ok 的值为 true，而当键值对不存在时，ok 的值为 false。如果只想判断某个键值对是否存在，可以将返回的真正的值设置为匿名变量</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>_, ok <span style=color:#666>:=</span> map1[key1]
</code></pre></div><p>map中元素的删除使用内置函数<code>delete()</code>，格式如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f>delete</span>(mapname, keyname)
</code></pre></div><p>如果键值对不存在，删除操作也不会产生错误</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>mapLit <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#b44>&#34;one&#34;</span>: <span style=color:#666>1</span>, <span style=color:#b44>&#34;two&#34;</span>: <span style=color:#666>2</span>}
<span style=color:#a2f>delete</span>(mapLit, <span style=color:#b44>&#34;one&#34;</span>)
</code></pre></div><p>但 Golang 并没有提供清空 map 中所有元素的方法，清空 map 的唯一办法就是重新 make 一个新的 map</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>mapLit <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#b44>&#34;one&#34;</span>: <span style=color:#666>1</span>, <span style=color:#b44>&#34;two&#34;</span>: <span style=color:#666>2</span>}
mapLit = <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>)
</code></pre></div><h3 id=33-遍历map>3.3 遍历map</h3><p>for-range可用于遍历map</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>for</span> key, value <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> map1 {
	<span style=color:#666>...</span>
}
</code></pre></div><p>其中第一个返回值 key 是 map 中的 key 值，第二个返回值 value 则是 key 对应的 value 值。如果只关心值，可以省略键</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>for</span> _, value <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> map1 {
	<span style=color:#666>...</span>
}
</code></pre></div><p>而如果只关心键，则可以省略值</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>for</span> key <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> map1 {
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;key is: %d\n&#34;</span>, key)
}
</code></pre></div><p>还需要知道的一点是，for-range 结构虽然能遍历整个 map，但我们并不知道 map 中键值对排列的顺序，并不是按 key 的顺序排列的，也不是按 value 的顺序排列。</p><p>如果想要为 map 排序，那么就需要先通过遍历将 map 的所有数据复制到切片中，再对切片排序，最后打印出来</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// the telephone alphabet:
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
	<span style=color:#b44>&#34;sort&#34;</span>
)

<span style=color:#a2f;font-weight:700>var</span> barVal = <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>{<span style=color:#b44>&#34;alpha&#34;</span>: <span style=color:#666>34</span>, <span style=color:#b44>&#34;bravo&#34;</span>: <span style=color:#666>56</span>, <span style=color:#b44>&#34;charlie&#34;</span>: <span style=color:#666>23</span>}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;unsorted:&#34;</span>)
	<span style=color:#a2f;font-weight:700>for</span> k, v <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> barVal {
		fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;Key: %v, Value: %v ; &#34;</span>, k, v)
	}
	keys <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#a2f>len</span>(barVal))
	i <span style=color:#666>:=</span> <span style=color:#666>0</span>
	<span style=color:#a2f;font-weight:700>for</span> k <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> barVal {
		keys[i] = k
		i<span style=color:#666>++</span>
	}
	sort.<span style=color:#00a000>Strings</span>(keys)
	fmt.<span style=color:#00a000>Println</span>()
	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;sorted:&#34;</span>)
	<span style=color:#a2f;font-weight:700>for</span> _, k <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> keys {
		fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;Key: %v, Value: %v ; &#34;</span>, k, barVal[k])
	}
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>unsorted:
Key: alpha, Value: <span style=color:#666>34</span> ; Key: bravo, Value: <span style=color:#666>56</span> ; Key: charlie, Value: <span style=color:#666>23</span> ; 
sorted:
Key: alpha, Value: <span style=color:#666>34</span> ; Key: bravo, Value: <span style=color:#666>56</span> ; Key: charlie, Value: <span style=color:#666>23</span> ; 

</code></pre></div><p>上例按key进行了排序并输出，如果想要更好的显示，可以使用结构体切片</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> name <span style=color:#a2f;font-weight:700>struct</span> {
	key <span style=color:#0b0;font-weight:700>string</span>
	value <span style=color:#0b0;font-weight:700>int</span>
}
</code></pre></div><h3 id=34-map类型的切片>3.4 map类型的切片</h3><p>map类型的切片是一个很有意思的结构，构造它需要使用两次<code>make()</code>函数，第一次分配切片，第二次分配切片中的每个map元素</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#080;font-style:italic>// Version A:
</span><span style=color:#080;font-style:italic></span>	items <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>int</span>]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>5</span>)
	<span style=color:#a2f;font-weight:700>for</span> i<span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> items {
		items[i] = <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>int</span>]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>1</span>)
		items[i][<span style=color:#666>1</span>] = <span style=color:#666>2</span>
	}
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;Version A: Value of items: %v\n&#34;</span>, items)

	<span style=color:#080;font-style:italic>// Version B: NOT GOOD!
</span><span style=color:#080;font-style:italic></span>	items2 <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([]<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>int</span>]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>5</span>)
	<span style=color:#a2f;font-weight:700>for</span> _, item <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> items2 {
		item = <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>int</span>]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#666>1</span>) <span style=color:#080;font-style:italic>// item is only a copy of the slice element.
</span><span style=color:#080;font-style:italic></span>		item[<span style=color:#666>1</span>] = <span style=color:#666>2</span> <span style=color:#080;font-style:italic>// This &#39;item&#39; will be lost on the next iteration.
</span><span style=color:#080;font-style:italic></span>	}
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;Version B: Value of items: %v\n&#34;</span>, items2)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>Version A: Value of items: [<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#666>1</span>:<span style=color:#666>2</span>] <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#666>1</span>:<span style=color:#666>2</span>] <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#666>1</span>:<span style=color:#666>2</span>] <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#666>1</span>:<span style=color:#666>2</span>] <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#666>1</span>:<span style=color:#666>2</span>]]
Version B: Value of items: [<span style=color:#a2f;font-weight:700>map</span>[] <span style=color:#a2f;font-weight:700>map</span>[] <span style=color:#a2f;font-weight:700>map</span>[] <span style=color:#a2f;font-weight:700>map</span>[] <span style=color:#a2f;font-weight:700>map</span>[]]

</code></pre></div><p>应该意识到，for-range 结构中，value 只是值的拷贝，对它做操作不会影响原值，因此上例中第二种写法是错误的，真正的 map 元素并没有得到初始化。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/go%e8%af%ad%e6%b3%95 rel=tag title=Go语法>#Go语法#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-info><p><span>声明：</span>Golang语法基础6-数组、切片与映射</p><p><span>链接：</span>https://shuzang.github.io/2019/11/golang-syntax-6-array-slice-and-map/</p><p><span>作者：</span>书藏</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://shuzang.github.io/2019/11/medicine-and-health-5-medical-insurance-and-medical-treatment/ rel=next title=医药健康3-医保及就医><i class="fa fa-chevron-left"></i>医药健康3-医保及就医</a></div><div class="post-nav-prev post-nav-item"><a href=https://shuzang.github.io/2019/11/hugo-blog-themes-collection/ rel=prev title=hugo搭建个人博客5-博客收集>hugo搭建个人博客5-博客收集
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span>
<span class=links-of-author-item><a href="https://www.douban.com/people/159916010/?_i=9150521DKS5bK1" target=_blank title=豆瓣><i class="fa fa-fw fa-film"></i>豆瓣</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-数组>1. 数组</a></li><li><a href=#2-切片>2. 切片</a><ul><li><a href=#21-声明与使用>2.1 声明与使用</a></li><li><a href=#22-常用操作>2.2 常用操作</a></li></ul></li><li><a href=#3-映射>3. 映射</a><ul><li><a href=#31--声明与初始化>3.1 声明与初始化</a></li><li><a href=#32-访问与删除map中的元素>3.2 访问与删除map中的元素</a></li><li><a href=#33-遍历map>3.3 遍历map</a></li><li><a href=#34-map类型的切片>3.4 map类型的切片</a></li></ul></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2018 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer();});</script><script type=text/javascript>$(function(){if(detectIE()>0){$.getScript(document.location.protocol+'//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',function(){new Waline({el:'#wcomments',visitor:true,avatar:'wavatar',avatarCDN:'https://sdn.geekzu.org/avatar/',avatarForce:!1,wordLimit:'200',placeholder:' 欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^ ',requiredFields:['nick','mail'],serverURL:"Your WalineSerURL",lang:"zh-cn"});});}else{$('#wcomments').html('抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。');}});</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>
<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Golang语法基础8-结构体与方法 - 书藏的博客</title><meta name=keywords content="博客,程序员,区块链，思考,读书,笔记,生活,电影,旅游,"><meta name=author content="书藏"><meta property="og:title" content="Golang语法基础8-结构体与方法"><meta property="og:site_name" content="书藏的博客"><meta property="og:image" content="/img/avatar.png"><meta name=title content="Golang语法基础8-结构体与方法 - 书藏的博客"><meta name=description content="书藏的个人博客，记录学习的东西，以月刊记录生活"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-209130979-1"></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-209130979-1 ');</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><div class=multi-lang-switch><i class="fa fa-fw fa-language" style=margin-right:5px></i><a class=lang-link id=zh-cn href=#>中文</a></div><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>书藏的博客</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>凡心所向，素履以往</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span><span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://shuzang.github.io/2019/11/golang-syntax-8-struct-and-method/ itemprop=url>Golang语法基础8-结构体与方法</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i><span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2019-11-26">2019-11-26</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i><span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF itemprop=url rel=index style=text-decoration:underline><span itemprop=name>Golang学习之路</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i><span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>4404 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i><span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>9分钟</span></span>
<span id=/2019/11/golang-syntax-8-struct-and-method/ class=leancloud_visitors data-flag-title=Golang语法基础8-结构体与方法>|
<i class="fa fa-binoculars fa-fw"></i><span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>结构体是一种非常重要的结构，用到的地方非常多，在 Go 中，结构体还是实现面向对象编程的基础。</p><h2 id=1-结构体>1. 结构体</h2><h3 id=11-定义与初始化>1.1 定义与初始化</h3><p>结构体定义方式如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> identifier <span style=color:#a2f;font-weight:700>struct</span> {
    field1 type1
    field2 type2
    <span style=color:#666>...</span>
}
</code></pre></div><p>大括号中的每一行称为一个字段，每个字段都有一个类型和一个名字，在一个结构体中，字段名必须是唯一的。结构体名和字段名的命名遵循可见性规则，即使用首字母的大小写来表示可导出和不可导出。但是需要注意，一个可导出的结构体类型中可以存在不可导出的字段。</p><p>结构体的字段可以是任意类型，甚至可以是结构体本身、函数或者接口。一个简单的结构体定义示例如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> T <span style=color:#a2f;font-weight:700>struct</span> {
    a,b <span style=color:#0b0;font-weight:700>int</span>
}
</code></pre></div><p>结构体是自定义数据类型，因此我们可以向基本数据类型一样声明/定义一个结构体类型的变量，声明时会分配内存并默认使用每个字段类型的零值来初始化。我们也可以手动初始化一个结构体，使用点号符给字段赋值，示例如下。另外，访问结构体内字段的值时同样使用点号符，这种使用点号符赋值和获取字段值的方式叫做<strong>选择器(selector)</strong>，</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> s T
s.a = <span style=color:#666>5</span>
s.b = <span style=color:#666>8</span>
</code></pre></div><p>由于结构体也是值类型，使用new函数创建。注意，使用 new 得到的 t 是指向结构体的指针。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>var</span> t <span style=color:#666>*</span>T = <span style=color:#a2f>new</span>(T)
t <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(T) <span style=color:#080;font-style:italic>// 简单方便地写法，最常用
</span></code></pre></div><p>至此我们注意到，使用结构体时我们可能遇到两种类型：结构体类型和结构体指针类型，这两种类型都可以通过选择器的方式来使用，如下，v.i 和 p.i 都可以得到正确的值，在理解的时候可以想象底层对结构体指针 p 自动做了解引用，如 (*p).i。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> myStruct <span style=color:#a2f;font-weight:700>struct</span> { i <span style=color:#0b0;font-weight:700>int</span> }
<span style=color:#a2f;font-weight:700>var</span> v myStruct    <span style=color:#080;font-style:italic>// v是结构体类型变量
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> p <span style=color:#666>*</span>myStruct   <span style=color:#080;font-style:italic>// p是指向一个结构体类型变量的指针
</span><span style=color:#080;font-style:italic></span>v.i
p.<span style=color:#00a000>i</span>
(<span style=color:#666>*</span>p).i
</code></pre></div><p>除使用选择器初始化结构体字段外，一种更简短更常用的结构体初始化方法如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>ms <span style=color:#666>:=</span> struct1{<span style=color:#666>10</span>, <span style=color:#666>15.5</span>, <span style=color:#b44>&#34;Chris&#34;</span>}  <span style=color:#080;font-style:italic>//结构体类型
</span><span style=color:#080;font-style:italic></span>ms <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>struct1{<span style=color:#666>10</span>, <span style=color:#666>15.5</span>, <span style=color:#b44>&#34;Chris&#34;</span>}  <span style=color:#080;font-style:italic>//结构体指针类型
</span><span style=color:#080;font-style:italic></span>ms <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>struct1{f1:<span style=color:#666>15.5</span><span>，</span>i1:<span style=color:#666>10</span>}  <span style=color:#080;font-style:italic>//括号内声明字段名，这样可以不按定义的字段顺序，甚至省略部分字段
</span></code></pre></div><p>其中第二行称为混合字面量语法，但底层仍然会调用<code>new()</code>，因此与使用 <code>new()</code> 初始化是等同的。以<code>type Point struct {x,y int}</code>为例，这几种初始化方式的内存布局如下</p><p><img src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/Go_20191126_3EkqRU.jpg alt=结构体内存布局 style=zoom:80%></p><p>从上图可以看出，结构体和它包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套其它的结构体，同样如此。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Rect1 <span style=color:#a2f;font-weight:700>struct</span> {Min, Max Point }
<span style=color:#a2f;font-weight:700>type</span> Rect2 <span style=color:#a2f;font-weight:700>struct</span> {Min, Max <span style=color:#666>*</span>Point }
</code></pre></div><p><img src="https://github.com/unknwon/the-way-to-go_ZH_CN/raw/master/eBook/images/10.1_fig10.2.jpg?raw=true" alt=嵌套结构体内存布局></p><p>一个使用结构体的完整例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>type</span> struct1 <span style=color:#a2f;font-weight:700>struct</span> {
    i1  <span style=color:#0b0;font-weight:700>int</span>
    f1  <span style=color:#0b0;font-weight:700>float32</span>
    str <span style=color:#0b0;font-weight:700>string</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
    ms <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(struct1)
    ms.i1 = <span style=color:#666>10</span>
    ms.f1 = <span style=color:#666>15.5</span>
    ms.str= <span style=color:#b44>&#34;Chris&#34;</span>

    fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The int is: %d\n&#34;</span>, ms.i1)
    fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The float is: %f\n&#34;</span>, ms.f1)
    fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The string is: %s\n&#34;</span>, ms.str)
    fmt.<span style=color:#00a000>Println</span>(ms)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>The <span style=color:#0b0;font-weight:700>int</span> is: <span style=color:#666>10</span>
The <span style=color:#0b0;font-weight:700>float</span> is: <span style=color:#666>15.500000</span>
The <span style=color:#0b0;font-weight:700>string</span> is: Chris
<span style=color:#666>&amp;</span>{<span style=color:#666>10</span> <span style=color:#666>15.5</span> Chris}
</code></pre></div><h3 id=12-结构体标签>1.2 结构体标签</h3><p>实际上，一个完整的结构体定义，在字段名和类型外，还有一个标签(tag)部分。标签是一个字符串，用来对字段进行一定的说明，对程序功能没有太大的作用，因此前面才没有介绍。正如我们说的，它的主要作用就是对字段进行说明，标签只有包 <code>reflect</code> 能获取。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
	<span style=color:#b44>&#34;reflect&#34;</span>
)

<span style=color:#a2f;font-weight:700>type</span> TagType <span style=color:#a2f;font-weight:700>struct</span> { <span style=color:#080;font-style:italic>// tags
</span><span style=color:#080;font-style:italic></span>	field1 <span style=color:#0b0;font-weight:700>bool</span>   <span style=color:#b44>&#34;An important answer&#34;</span>
	field2 <span style=color:#0b0;font-weight:700>string</span> <span style=color:#b44>&#34;The name of the thing&#34;</span>
	field3 <span style=color:#0b0;font-weight:700>int</span>    <span style=color:#b44>&#34;How much there are&#34;</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	tt <span style=color:#666>:=</span> TagType{<span style=color:#a2f;font-weight:700>true</span>, <span style=color:#b44>&#34;Barak Obama&#34;</span>, <span style=color:#666>1</span>}
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; <span style=color:#666>3</span>; i<span style=color:#666>++</span> {
		<span style=color:#00a000>refTag</span>(tt, i)
	}
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>refTag</span>(tt TagType, ix <span style=color:#0b0;font-weight:700>int</span>) {
	ttType <span style=color:#666>:=</span> reflect.<span style=color:#00a000>TypeOf</span>(tt)
	ixField <span style=color:#666>:=</span> ttType.<span style=color:#00a000>Field</span>(ix)
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;%v\n&#34;</span>, ixField.Tag)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>An important answer
The name of the thing
How much there are
</code></pre></div><h3 id=13-匿名字段与内嵌结构体>1.3 匿名字段与内嵌结构体</h3><p>结构体的字段名其实和变量很相似，不需要时也可以用空白符 <code>_</code> 代替，但实际上，也可以直接省略，即整个字段只有类型，此时类型就是字段名，这种字段叫做<strong>匿名字段</strong>。如下例，通过类型 <code>t.float32</code> 来获取存储在匿名字段中的数据，也因为这种调用方式，一个结构体中对每一种数据类型只能有一个匿名字段。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>type</span> T <span style=color:#a2f;font-weight:700>struct</span> {
	a       <span style=color:#0b0;font-weight:700>int</span>
	<span style=color:#0b0;font-weight:700>float32</span> <span style=color:#080;font-style:italic>// anonymous field
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	t <span style=color:#666>:=</span> T{<span style=color:#666>6</span>, <span style=color:#666>7.5</span>}
	fmt.<span style=color:#00a000>Println</span>(t.<span style=color:#0b0;font-weight:700>float32</span>)
}

<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>{<span style=color:#666>6</span> <span style=color:#666>7.5</span>}
</code></pre></div><p>由于结构体本身也是一种数据类型，因此也可以作为匿名字段使用，称为<strong>内嵌结构体</strong>。通过内嵌结构体可以实现 OO 编程种的继承。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>type</span> A <span style=color:#a2f;font-weight:700>struct</span> {
	ax, ay <span style=color:#0b0;font-weight:700>int</span>
}

<span style=color:#a2f;font-weight:700>type</span> B <span style=color:#a2f;font-weight:700>struct</span> {
	A
	bx, by <span style=color:#0b0;font-weight:700>float32</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	b <span style=color:#666>:=</span> B{A{<span style=color:#666>1</span>, <span style=color:#666>2</span>}, <span style=color:#666>3.0</span>, <span style=color:#666>4.0</span>}
	fmt.<span style=color:#00a000>Println</span>(b.ax, b.ay, b.bx, b.by)
	fmt.<span style=color:#00a000>Println</span>(b.A)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span><span style=color:#666>1</span> <span style=color:#666>2</span> <span style=color:#666>3</span> <span style=color:#666>4</span>
{<span style=color:#666>1</span> <span style=color:#666>2</span>}
</code></pre></div><p>使用内嵌结构体的时候，很可能会出现命名冲突（继承来的字段名和当前结构体的某个字段名相同），这种情况下外层的名字会覆盖内层的名字，但两者的内存空间都会保留，下例中<code>d.b</code>的调用不会出错，指的是float32，而不是<code>B.b</code>，进行内层调用可以使用<code>d.B.b</code></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> B <span style=color:#a2f;font-weight:700>struct</span> {a, b <span style=color:#0b0;font-weight:700>int</span>}
<span style=color:#a2f;font-weight:700>type</span> D <span style=color:#a2f;font-weight:700>struct</span> {B; b <span style=color:#0b0;font-weight:700>float32</span>}
<span style=color:#a2f;font-weight:700>var</span> d D
</code></pre></div><p>但下面这种情况，<code>c.a</code>的调用会导致编译器错误,只能由程序员手动修改</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> A <span style=color:#a2f;font-weight:700>struct</span> {a <span style=color:#0b0;font-weight:700>int</span>}
<span style=color:#a2f;font-weight:700>type</span> B <span style=color:#a2f;font-weight:700>struct</span> {a, b <span style=color:#0b0;font-weight:700>int</span>}

<span style=color:#a2f;font-weight:700>type</span> C <span style=color:#a2f;font-weight:700>struct</span> {A; B}
<span style=color:#a2f;font-weight:700>var</span> c C
</code></pre></div><h3 id=14-结构体工厂>1.4 结构体工厂</h3><p>可以为结构体定义一个工厂来创建结构体实例，工厂的名字通常以new或New开头，这是一种很常用的方法。假设定义了如下File结构体类型</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> File <span style=color:#a2f;font-weight:700>struct</span> {
    fd <span style=color:#0b0;font-weight:700>int</span> <span style=color:#080;font-style:italic>//文件描述符
</span><span style=color:#080;font-style:italic></span>    name <span style=color:#0b0;font-weight:700>string</span> <span style=color:#080;font-style:italic>//文件名
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>下面是为File结构体创建的工厂，返回一个指向结构体的指针</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>NewFile</span>(fd <span style=color:#0b0;font-weight:700>int</span>, name <span style=color:#0b0;font-weight:700>string</span>) <span style=color:#666>*</span>File {
    <span style=color:#a2f;font-weight:700>if</span> fd &lt; <span style=color:#666>0</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
    }

    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>&amp;</span>File{fd, name}
}
</code></pre></div><p>然后这样调用它</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>f <span style=color:#666>:=</span> <span style=color:#00a000>NewFile</span>(<span style=color:#666>10</span>, <span style=color:#b44>&#34;./test.txt&#34;</span>)
</code></pre></div><p>这种方式可以模拟OO编程中使用<code>new</code>的实例化，如果要完全等同，还需要利用可见性规则禁止使用Go内置的<code>new()</code>函数</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> matrix <span style=color:#a2f;font-weight:700>struct</span> {
    <span style=color:#666>...</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>NewMatrix</span>(params) <span style=color:#666>*</span>matrix {
    m <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(matrix) <span style=color:#080;font-style:italic>// 初始化 m
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>return</span> m
}
</code></pre></div><p>然后在其它包里就只能使用工厂创建结构体实例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main
<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;matrix&#34;</span>
<span style=color:#666>...</span>
wrong <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(matrix.matrix)     <span style=color:#080;font-style:italic>// 编译失败（matrix 是私有的）
</span><span style=color:#080;font-style:italic></span>right <span style=color:#666>:=</span> matrix.<span style=color:#00a000>NewMatrix</span>(<span style=color:#666>...</span>)  <span style=color:#080;font-style:italic>// 实例化 matrix 的唯一方式
</span></code></pre></div><h2 id=2-方法>2. 方法</h2><p>Go中的方法是作用在接收者上的一个函数，接收者是某种类型的变量。定义方法的一般格式如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (recv receiver_type) <span style=color:#00a000>methodName</span>(parameter_list) (return_value_list) { <span style=color:#666>...</span> }
</code></pre></div><p>在<code>func</code>关键字之后，方法名之前的括号中声明接收者和接收者类型。同样还可以看到，方法的本质仍然是函数，只不过是针对特定变量的函数，除了括号中的接收者声明，其它部分和普通函数没有不同。</p><p>接收者几乎可以是任何类型的变量，包括基本数据类型、数组的别名类型、结构体、函数等，但不可以是接口，因为方法是需要实现的，而接口只是抽象定义。</p><p>如果接收者变量<code>recv</code>已经在其它地方进行了初始化，Method1是它的方法名，那么方法的调用格式为<code>recv.Method1()</code>，同结构体相似，如果<code>recv</code>是指针，调用时自动解引用。</p><p>如果方法不需要使用<code>recv</code>的值，可以用空白符<code>_</code>替换它</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (_ receiver_type) <span style=color:#00a000>methodName</span>(parameter_list) (return_value_list) { <span style=color:#666>...</span> }
</code></pre></div><p>类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集（method set）。</p><p>一个接收者变量加上它的方法等价于面向对象中的一个类，区别只在于Go中方法的代码与变量定义是分离的，只要在同一个包中即可。</p><p>因为方法是函数，所以方法同样不允许重载，但不同的接收者变量可以有相同名字的方法，即使它们在同一个包中，一个例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (a <span style=color:#666>*</span>denseMatrix) <span style=color:#00a000>Add</span>(b Matrix) Matrix
<span style=color:#a2f;font-weight:700>func</span> (a <span style=color:#666>*</span>sparseMatrix) <span style=color:#00a000>Add</span>(b Matrix) Matrix
</code></pre></div><p>一个结构体方法的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>type</span> TwoInts <span style=color:#a2f;font-weight:700>struct</span> {
	a <span style=color:#0b0;font-weight:700>int</span>
	b <span style=color:#0b0;font-weight:700>int</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	two1 <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(TwoInts)
	two1.a = <span style=color:#666>12</span>
	two1.b = <span style=color:#666>10</span>

	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The sum is: %d\n&#34;</span>, two1.<span style=color:#00a000>AddThem</span>())
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;Add them to the param: %d\n&#34;</span>, two1.<span style=color:#00a000>AddToParam</span>(<span style=color:#666>20</span>))

	two2 <span style=color:#666>:=</span> TwoInts{<span style=color:#666>3</span>, <span style=color:#666>4</span>}
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;The sum is: %d\n&#34;</span>, two2.<span style=color:#00a000>AddThem</span>())
}

<span style=color:#a2f;font-weight:700>func</span> (tn <span style=color:#666>*</span>TwoInts) <span style=color:#00a000>AddThem</span>() <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>return</span> tn.a <span style=color:#666>+</span> tn.b
}

<span style=color:#a2f;font-weight:700>func</span> (tn <span style=color:#666>*</span>TwoInts) <span style=color:#00a000>AddToParam</span>(param <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>int</span> {
	<span style=color:#a2f;font-weight:700>return</span> tn.a <span style=color:#666>+</span> tn.b <span style=color:#666>+</span> param
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>The sum is: <span style=color:#666>22</span>
Add them to the param: <span style=color:#666>42</span>
The sum is: <span style=color:#666>7</span>
</code></pre></div><p>一个非结构体类型(数组别名)方法的例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;fmt&#34;</span>

<span style=color:#a2f;font-weight:700>type</span> IntVector []<span style=color:#0b0;font-weight:700>int</span>

<span style=color:#a2f;font-weight:700>func</span> (v IntVector) <span style=color:#00a000>Sum</span>() (s <span style=color:#0b0;font-weight:700>int</span>) {
	<span style=color:#a2f;font-weight:700>for</span> _, x <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> v {
		s <span style=color:#666>+=</span> x
	}
	<span style=color:#a2f;font-weight:700>return</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	fmt.<span style=color:#00a000>Println</span>(IntVector{<span style=color:#666>1</span>, <span style=color:#666>2</span>, <span style=color:#666>3</span>}.<span style=color:#00a000>Sum</span>()) <span style=color:#080;font-style:italic>// 输出是6
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>变量和定义在它上面的方法必须在同一个包里定义，如下例是错误的，这也是为什么不能定义int这样的基本类型的方法，但可以定义基本类型的别名的方法</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#34;container/list&#34;</span>

<span style=color:#a2f;font-weight:700>func</span> (p <span style=color:#666>*</span>list.List) <span style=color:#00a000>Iter</span>() {
	<span style=color:#080;font-style:italic>// ...
</span><span style=color:#080;font-style:italic></span>}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	lst <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(list.List)
	<span style=color:#a2f;font-weight:700>for</span> _= <span style=color:#a2f;font-weight:700>range</span> lst.<span style=color:#00a000>Iter</span>() {
	}
}
</code></pre></div><h3 id=21-函数和方法的区别>2.1 函数和方法的区别</h3><p>函数将变量作为参数：<strong>Function1(recv)</strong></p><p>方法在变量上被调用：<strong>recv.Method1()</strong></p><p>在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。</p><p><strong>不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：<code>method recv.Method1 is not an expression, must be called</code></strong></p><p>接收者必须有一个显式的名字，这个名字必须在方法中被使用。</p><p><strong>receiver_type</strong> 叫做 <strong>（接收者）基本类型</strong>，这个类型必须在和方法同样的包中被声明。</p><p>在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。</p><p><strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong></p><h3 id=22-指针或值作为接收者>2.2 指针或值作为接收者</h3><p>如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。一个例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
)

<span style=color:#a2f;font-weight:700>type</span> B <span style=color:#a2f;font-weight:700>struct</span> {
	thing <span style=color:#0b0;font-weight:700>int</span>
}

<span style=color:#a2f;font-weight:700>func</span> (b <span style=color:#666>*</span>B) <span style=color:#00a000>change</span>() { b.thing = <span style=color:#666>1</span> }

<span style=color:#a2f;font-weight:700>func</span> (b B) <span style=color:#00a000>write</span>() <span style=color:#0b0;font-weight:700>string</span> { <span style=color:#a2f;font-weight:700>return</span> fmt.<span style=color:#00a000>Sprint</span>(b) }

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	<span style=color:#a2f;font-weight:700>var</span> b1 B <span style=color:#080;font-style:italic>// b1是值
</span><span style=color:#080;font-style:italic></span>	b1.<span style=color:#00a000>change</span>()
	fmt.<span style=color:#00a000>Println</span>(b1.<span style=color:#00a000>write</span>())

	b2 <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(B) <span style=color:#080;font-style:italic>// b2是指针
</span><span style=color:#080;font-style:italic></span>	b2.<span style=color:#00a000>change</span>()
	fmt.<span style=color:#00a000>Println</span>(b2.<span style=color:#00a000>write</span>())
}

<span style=color:#080;font-style:italic>/* 输出：
</span><span style=color:#080;font-style:italic>{1}
</span><span style=color:#080;font-style:italic>{1}
</span><span style=color:#080;font-style:italic>*/</span>
</code></pre></div><p>指针方法和值方法都可以在指针或非指针上被调用，如上例，b1是值类型，而change()方法作用在指针类型上，b1.change()会被自动转换为(&b1).change()；b2是指针类型，但write()方法是值类型，b2.write()会被自动转换成(*b2).write()</p><h3 id=23-利用方法读取结构体中的未导出字段>2.3 利用方法读取结构体中的未导出字段</h3><p>本文开始对结构体的介绍中，提到结构体对外部可见，而结构体中的字段对外部不可见是可能发生的，对于这种情况，读取或修改结构体中的字段值可以通过作用在结构体上的方法完成，一个例子如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> person

<span style=color:#a2f;font-weight:700>type</span> Person <span style=color:#a2f;font-weight:700>struct</span> {
	firstName <span style=color:#0b0;font-weight:700>string</span>
	lastName  <span style=color:#0b0;font-weight:700>string</span>
}

<span style=color:#a2f;font-weight:700>func</span> (p <span style=color:#666>*</span>Person) <span style=color:#00a000>FirstName</span>() <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> p.firstName
}

<span style=color:#a2f;font-weight:700>func</span> (p <span style=color:#666>*</span>Person) <span style=color:#00a000>SetFirstName</span>(newName <span style=color:#0b0;font-weight:700>string</span>) {
	p.firstName = newName
}
</code></pre></div><p>对其中定义的结构体字段进行调用</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;./person&#34;</span>
	<span style=color:#b44>&#34;fmt&#34;</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	p <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(person.Person)
	<span style=color:#080;font-style:italic>// p.firstName undefined
</span><span style=color:#080;font-style:italic></span>	<span style=color:#080;font-style:italic>// (cannot refer to unexported field or method firstName)
</span><span style=color:#080;font-style:italic></span>	<span style=color:#080;font-style:italic>// p.firstName = &#34;Eric&#34;
</span><span style=color:#080;font-style:italic></span>	p.<span style=color:#00a000>SetFirstName</span>(<span style=color:#b44>&#34;Eric&#34;</span>)
	fmt.<span style=color:#00a000>Println</span>(p.<span style=color:#00a000>FirstName</span>()) <span style=color:#080;font-style:italic>// Output: Eric
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><h3 id=24-内嵌类型的方法与继承>2.4 内嵌类型的方法与继承</h3><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <strong>继承</strong> 了这些方法 ， 这个机制提供了一种简单的方式来模拟面向对象语言中的子类和继承相关的效果。一个示例如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
	<span style=color:#b44>&#34;math&#34;</span>
)

<span style=color:#a2f;font-weight:700>type</span> Point <span style=color:#a2f;font-weight:700>struct</span> {
	x, y <span style=color:#0b0;font-weight:700>float64</span>
}

<span style=color:#a2f;font-weight:700>func</span> (p <span style=color:#666>*</span>Point) <span style=color:#00a000>Abs</span>() <span style=color:#0b0;font-weight:700>float64</span> {
	<span style=color:#a2f;font-weight:700>return</span> math.<span style=color:#00a000>Sqrt</span>(p.x<span style=color:#666>*</span>p.x <span style=color:#666>+</span> p.y<span style=color:#666>*</span>p.y)
}

<span style=color:#a2f;font-weight:700>type</span> NamedPoint <span style=color:#a2f;font-weight:700>struct</span> {
	Point
	name <span style=color:#0b0;font-weight:700>string</span>
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	n <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>NamedPoint{Point{<span style=color:#666>3</span>, <span style=color:#666>4</span>}, <span style=color:#b44>&#34;Pythagoras&#34;</span>}
	fmt.<span style=color:#00a000>Println</span>(n.<span style=color:#00a000>Abs</span>()) <span style=color:#080;font-style:italic>// 打印5
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>使用同名方法可以覆盖父类型中的方法，比如在上例中添加如下代码，会打印100</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (n <span style=color:#666>*</span>NamedPoint) <span style=color:#00a000>Abs</span>() <span style=color:#0b0;font-weight:700>float64</span> {
	<span style=color:#a2f;font-weight:700>return</span> n.Point.<span style=color:#00a000>Abs</span>() <span style=color:#666>*</span> <span style=color:#666>100.</span>
}
</code></pre></div><p>因为一个结构体可以嵌入多个匿名类型，所以实际上可以实现简单的多重继承，如下例所示</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
)

<span style=color:#a2f;font-weight:700>type</span> Camera <span style=color:#a2f;font-weight:700>struct</span>{}

<span style=color:#a2f;font-weight:700>func</span> (c <span style=color:#666>*</span>Camera) <span style=color:#00a000>TakeAPicture</span>() <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#b44>&#34;Click&#34;</span>
}

<span style=color:#a2f;font-weight:700>type</span> Phone <span style=color:#a2f;font-weight:700>struct</span>{}

<span style=color:#a2f;font-weight:700>func</span> (p <span style=color:#666>*</span>Phone) <span style=color:#00a000>Call</span>() <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#b44>&#34;Ring Ring&#34;</span>
}

<span style=color:#a2f;font-weight:700>type</span> CameraPhone <span style=color:#a2f;font-weight:700>struct</span> {
	Camera
	Phone
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	cp <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(CameraPhone)
	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;Our new CameraPhone exhibits multiple behaviors...&#34;</span>)
	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;It exhibits behavior of a Camera: &#34;</span>, cp.<span style=color:#00a000>TakeAPicture</span>())
	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;It works like a Phone too: &#34;</span>, cp.<span style=color:#00a000>Call</span>())
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>Our new CameraPhone exhibits multiple behaviors<span style=color:#666>...</span>
It exhibits behavior of a Camera: Click
It works like a Phone too: Ring Ring
</code></pre></div><h3 id=25-在类型中嵌入功能>2.5 在类型中嵌入功能</h3><p>主要有两种方法来实现在类型中嵌入功能：</p><p>A：聚合（或组合）：包含一个所需功能类型的具名字段。</p><p>B：内嵌：内嵌（匿名地）所需功能类型，像前一节 10.6.5 所演示的那样。</p><p>假设有一个 <code>Customer</code> 类型，我们想让它通过 <code>Log</code> 类型来包含日志功能，<code>Log</code> 类型只是简单地包含一个累积的消息（当然它可以是复杂的）。如果想让特定类型都具备日志功能，你可以实现一个这样的 <code>Log</code> 类型，然后将它作为特定类型的一个字段，并提供 <code>Log()</code>，它返回这个日志的引用。</p><p>使用聚合方式实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
)

<span style=color:#a2f;font-weight:700>type</span> Log <span style=color:#a2f;font-weight:700>struct</span> {
	msg <span style=color:#0b0;font-weight:700>string</span>
}

<span style=color:#a2f;font-weight:700>type</span> Customer <span style=color:#a2f;font-weight:700>struct</span> {
	Name <span style=color:#0b0;font-weight:700>string</span>
	log  <span style=color:#666>*</span>Log
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	c <span style=color:#666>:=</span> <span style=color:#a2f>new</span>(Customer)
	c.Name = <span style=color:#b44>&#34;Barak Obama&#34;</span>
	c.log = <span style=color:#a2f>new</span>(Log)
	c.log.msg = <span style=color:#b44>&#34;1 - Yes we can!&#34;</span>
	<span style=color:#080;font-style:italic>// shorter
</span><span style=color:#080;font-style:italic></span>	c = <span style=color:#666>&amp;</span>Customer{<span style=color:#b44>&#34;Barak Obama&#34;</span>, <span style=color:#666>&amp;</span>Log{<span style=color:#b44>&#34;1 - Yes we can!&#34;</span>}}
	<span style=color:#080;font-style:italic>// fmt.Println(c) &amp;{Barak Obama 1 - Yes we can!}
</span><span style=color:#080;font-style:italic></span>	c.<span style=color:#00a000>Log</span>().<span style=color:#00a000>Add</span>(<span style=color:#b44>&#34;2 - After me the world will be a better place!&#34;</span>)
	<span style=color:#080;font-style:italic>//fmt.Println(c.log)
</span><span style=color:#080;font-style:italic></span>	fmt.<span style=color:#00a000>Println</span>(c.<span style=color:#00a000>Log</span>())

}

<span style=color:#a2f;font-weight:700>func</span> (l <span style=color:#666>*</span>Log) <span style=color:#00a000>Add</span>(s <span style=color:#0b0;font-weight:700>string</span>) {
	l.msg <span style=color:#666>+=</span> <span style=color:#b44>&#34;\n&#34;</span> <span style=color:#666>+</span> s
}

<span style=color:#a2f;font-weight:700>func</span> (l <span style=color:#666>*</span>Log) <span style=color:#00a000>String</span>() <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> l.msg
}

<span style=color:#a2f;font-weight:700>func</span> (c <span style=color:#666>*</span>Customer) <span style=color:#00a000>Log</span>() <span style=color:#666>*</span>Log {
	<span style=color:#a2f;font-weight:700>return</span> c.log
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span><span style=color:#666>1</span> <span style=color:#666>-</span> Yes we can!
<span style=color:#666>2</span> <span style=color:#666>-</span> After me the world will be a better place!
</code></pre></div><p>使用内嵌方式实现如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>package</span> main

<span style=color:#a2f;font-weight:700>import</span> (
	<span style=color:#b44>&#34;fmt&#34;</span>
)

<span style=color:#a2f;font-weight:700>type</span> Log <span style=color:#a2f;font-weight:700>struct</span> {
	msg <span style=color:#0b0;font-weight:700>string</span>
}

<span style=color:#a2f;font-weight:700>type</span> Customer <span style=color:#a2f;font-weight:700>struct</span> {
	Name <span style=color:#0b0;font-weight:700>string</span>
	Log
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
	c <span style=color:#666>:=</span> <span style=color:#666>&amp;</span>Customer{<span style=color:#b44>&#34;Barak Obama&#34;</span>, Log{<span style=color:#b44>&#34;1 - Yes we can!&#34;</span>}}
	c.<span style=color:#00a000>Add</span>(<span style=color:#b44>&#34;2 - After me the world will be a better place!&#34;</span>)
	fmt.<span style=color:#00a000>Println</span>(c)

}

<span style=color:#a2f;font-weight:700>func</span> (l <span style=color:#666>*</span>Log) <span style=color:#00a000>Add</span>(s <span style=color:#0b0;font-weight:700>string</span>) {
	l.msg <span style=color:#666>+=</span> <span style=color:#b44>&#34;\n&#34;</span> <span style=color:#666>+</span> s
}

<span style=color:#a2f;font-weight:700>func</span> (l <span style=color:#666>*</span>Log) <span style=color:#00a000>String</span>() <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> l.msg
}

<span style=color:#a2f;font-weight:700>func</span> (c <span style=color:#666>*</span>Customer) <span style=color:#00a000>String</span>() <span style=color:#0b0;font-weight:700>string</span> {
	<span style=color:#a2f;font-weight:700>return</span> c.Name <span style=color:#666>+</span> <span style=color:#b44>&#34;\nLog:&#34;</span> <span style=color:#666>+</span> fmt.<span style=color:#00a000>Sprintln</span>(c.Log)
}
<span style=color:#080;font-style:italic>//Output:
</span><span style=color:#080;font-style:italic></span>Barak Obama
Log:{<span style=color:#666>1</span> <span style=color:#666>-</span> Yes we can!
<span style=color:#666>2</span> <span style=color:#666>-</span> After me the world will be a better place!}
</code></pre></div><p>内嵌的类型不需要指针，<code>Customer</code> 也不需要 <code>Add</code> 方法，它使用 <code>Log</code> 的 <code>Add</code> 方法，<code>Customer</code> 有自己的 <code>String</code> 方法，并且在它里面调用了 <code>Log</code> 的 <code>String</code> 方法。</p><p>如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。</p><p>因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/go%e8%af%ad%e6%b3%95 rel=tag title=Go语法>#Go语法#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-info><p><span>声明：</span>Golang语法基础8-结构体与方法</p><p><span>链接：</span>https://shuzang.github.io/2019/11/golang-syntax-8-struct-and-method/</p><p><span>作者：</span>书藏</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://shuzang.github.io/2019/11/blockchain-based-access-control-for-iot/ rel=next title=研究记录9-区块链用于物联网访问控制梳理><i class="fa fa-chevron-left"></i>研究记录9-区块链用于物联网访问控制梳理</a></div><div class="post-nav-prev post-nav-item"><a href=https://shuzang.github.io/2019/11/golang-syntax-9-interface-and-reflect/ rel=prev title=Golang语法基础9-接口与反射>Golang语法基础9-接口与反射
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar.png alt=书藏><p class=site-author-name itemprop=name>书藏</p><p class="site-description motion-element" itemprop=description></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>334</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>23</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/shuzang/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0>论文笔记</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B9%A6%E8%97%8F%E7%9A%84%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A>书藏的生活周刊</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95>科研记录</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E8%AF%AD%E6%B3%95>Go语法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80>计算机基础</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%9D%82%E8%B0%88>杂谈</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE>区块链</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95>数据结构与算法</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD>生活技能</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/go%E5%AE%9E%E6%88%98>Go实战</a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2018 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=copyright-author>书藏的博客</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.63.2</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user"></i><span class=busuanzi-value id=busuanzi_value_site_uv></span></span><span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i><span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script><script type=text/javascript src=/js/search.js></script><script type=text/javascript src=/js/affix.js></script><script type=text/javascript src=/js/scrollspy.js></script><script type=text/javascript>function detectIE(){var ua=window.navigator.userAgent;var msie=ua.indexOf('MSIE ');var trident=ua.indexOf('Trident/');var edge=ua.indexOf('Edge/');if(msie>0||trident>0||edge>0){return-1;}
return 1;}
function getCntViewHeight(){var docHeight=$('#content').height(),winHeight=$(window).height(),cntViewHeight=(docHeight>winHeight)?(docHeight-winHeight):($(document).height()-winHeight);return cntViewHeight;}
function getScrollbarWidth(){var $div=$('<div />').addClass('scrollbar-measure').prependTo('body');var div=$div[0];var scrollbarWidth=div.offsetWidth-div.clientWidth;$div.remove();return scrollbarWidth;}
function registerBackTop(){var THRESHOLD=50;var $top=$('.back-to-top');$(window).on('scroll',function(){$top.toggleClass('back-to-top-on',window.pageYOffset>THRESHOLD);var scrollTop=$(window).scrollTop();var cntViewHeight=getCntViewHeight();var scrollPercent=(scrollTop)/(cntViewHeight);var scrollPercentRounded=Math.round(scrollPercent*100);var scrollPercentMaxed=(scrollPercentRounded>100)?100:scrollPercentRounded;$('#scrollpercent>span').html(scrollPercentMaxed);});$top.on('click',function(){$("html,body").animate({scrollTop:0,screenLeft:0,},800);});}
function initScrollSpy(){var tocSelector='.post-toc';var $tocElement=$(tocSelector);var activeCurrentSelector='.active-current';$tocElement.on('activate.bs.scrollspy',function(){var $currentActiveElement=$(tocSelector+' .active').last();removeCurrentActiveClass();$currentActiveElement.addClass('active-current');}).on('clear.bs.scrollspy',removeCurrentActiveClass);$('body').scrollspy({target:tocSelector});function removeCurrentActiveClass(){$(tocSelector+' '+activeCurrentSelector).removeClass(activeCurrentSelector.substring(1));}}
function initAffix(){var headerHeight=$('.header-inner').height();var footerOffset=parseInt($('.main').css('padding-bottom'),10);var sidebarTop=headerHeight+10;$('.sidebar-inner').affix({offset:{top:sidebarTop,bottom:footerOffset}});$(document).on('affixed.bs.affix',function(){updateTOCHeight(document.body.clientHeight-100);});}
function initTOCDimension(){var updateTOCHeightTimer;$(window).on('resize',function(){updateTOCHeightTimer&&clearTimeout(updateTOCHeightTimer);updateTOCHeightTimer=setTimeout(function(){var tocWrapperHeight=document.body.clientHeight-100;updateTOCHeight(tocWrapperHeight);},0);});updateTOCHeight(document.body.clientHeight-100);var scrollbarWidth=getScrollbarWidth();$('.post-toc').css('width','calc(100% + '+scrollbarWidth+'px)');}
function updateTOCHeight(height){height=height||'auto';$('.post-toc').css('max-height',height);}
$(function(){var sidebarTop=$('.header-inner').height()+10;$('#sidebar').css({'margin-top':sidebarTop}).show();var sidebarMt=parseInt($('#sidebar').css('margin-top'));var sidebarInHeight=parseInt($('.sidebar-inner').css('height'));var sideHeight=sidebarMt+sidebarInHeight;var contentHeight=$('.content-wrap').height();if(contentHeight<sideHeight){$('.content-wrap').css('min-height',sideHeight);}
$('.site-nav-toggle').on('click',function(){var $siteNav=$('.site-nav');var $toggleLine=$('.toggle');var ON_CLASS_NAME='site-nav-on';var CLOSE_CLASS_NAME='toggle-close';var isSiteNavOn=$siteNav.hasClass(ON_CLASS_NAME);var animateAction=isSiteNavOn?'slideUp':'slideDown';var animateCallback=isSiteNavOn?'removeClass':'addClass';$siteNav.stop()[animateAction]('normal',function(){$siteNav[animateCallback](ON_CLASS_NAME);$toggleLine[animateCallback](CLOSE_CLASS_NAME);});});registerBackTop();initScrollSpy();initAffix();initTOCDimension();$('.sidebar-nav-toc').click(function(){$(this).addClass('sidebar-nav-active');$(this).next().removeClass('sidebar-nav-active');$('.'+$(this).next().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});$('.sidebar-nav-overview').click(function(){$(this).addClass('sidebar-nav-active');$(this).prev().removeClass('sidebar-nav-active');$('.'+$(this).prev().attr('data-target')).toggle(500);$('.'+$(this).attr('data-target')).toggle(500);});});</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script><script type=text/javascript>$(function(){$('.post-body').viewer();});</script><script type=text/javascript>$(function(){if(detectIE()>0){$.getScript(document.location.protocol+'//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',function(){new Waline({el:'#wcomments',visitor:true,avatar:'wavatar',avatarCDN:'https://sdn.geekzu.org/avatar/',avatarForce:!1,wordLimit:'200',placeholder:' 欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^ ',requiredFields:['nick','mail'],serverURL:"Your WalineSerURL",lang:"zh-cn"});});}else{$('#wcomments').html('抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。');}});</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script></body></html>